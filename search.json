[{"title":"CSAPP 01 - Bits, Bytes and Integers","url":"/2020/06/28/CSAPP-01-Bits-Bytes-and-Integers/","content":"<p>Notes for Bits, Bytes and Integers.</p>\n<a id=\"more\"></a>\n<h3 id=\"用bit来表示和操纵集合\"><a href=\"#用bit来表示和操纵集合\" class=\"headerlink\" title=\"用bit来表示和操纵集合\"></a>用bit来表示和操纵集合</h3><p>宽为 $w$ 的bit向量可用于表示 $A=\\{0,\\cdots,w-1\\}$ 的子集，$j \\in A$ 当且仅当 $a_j=1$。</p>\n<p>例如，01101001可表示 $\\{0, 3, 5, 6\\}$；01010101可表示 $\\{0, 2, 4, 6\\}$。</p>\n<p>&amp;，｜，~可分别求集合的交、并、补集。</p>\n<p><strong>注：</strong> C++提供了bitset库用于管理一系列的bit位。</p>\n<h3 id=\"有符号数的计算公式\"><a href=\"#有符号数的计算公式\" class=\"headerlink\" title=\"有符号数的计算公式\"></a>有符号数的计算公式</h3><script type=\"math/tex; mode=display\">\n-x_{w-1}\\cdot2^{w-1}+\\sum_{i=0}^{w-2}x_i\\cdot2^i</script><p>其中 $w$ 是位宽，最高位第$w-1$是符号位。</p>\n<h3 id=\"C中的无符号数\"><a href=\"#C中的无符号数\" class=\"headerlink\" title=\"C中的无符号数\"></a>C中的无符号数</h3><ol>\n<li><p><strong>int和unsigned相互转换</strong></p>\n<p>保留bit模式，但根据符号位的不同含义重新翻译其值。</p>\n<p>int和unsigned出现在同一个表达式时，int会被隐式转换成unsigned，从而可能导致一些混乱。</p>\n<p>例如：</p>\n<p>-1 &lt; 0</p>\n<p>-1 &gt; 0U</p>\n</li>\n<li><p><strong>一段危险的代码</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = cnt - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">    a[i] = a[i + <span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p>unsigned始终不小于0。当其等于0时，再进行一次自减将变成UINT_MAX，从而导致死循环。</p>\n<p>sizeof默认返回unsigned，在使用其返回值时同样应注意以上代码的问题。</p>\n<p>若想要使用unsigned作为循环索引，正确的姿势是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = cnt - <span class=\"number\">2</span>; i &lt; cnt; i--)</span><br><span class=\"line\">    a[i] = a[i + <span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"有符号数的位扩展与截断\"><a href=\"#有符号数的位扩展与截断\" class=\"headerlink\" title=\"有符号数的位扩展与截断\"></a>有符号数的位扩展与截断</h3></li>\n<li><p><strong>位扩展</strong></p>\n<p>用现有最高位填充所有扩展位。如short ➡️ int时会发生。</p>\n</li>\n<li><p><strong>位截断</strong></p>\n<p>直接截去多余的位，可能出现正数变负数，负数变正数。如int ➡️ short时会发生。</p>\n</li>\n</ol>\n<h3 id=\"移位计算\"><a href=\"#移位计算\" class=\"headerlink\" title=\"移位计算\"></a>移位计算</h3><ol>\n<li><strong>左移</strong><ul>\n<li>$u &lt;&lt; k = u * 2^k$</li>\n<li>对于有符号数和无符号数都适用</li>\n</ul>\n</li>\n<li><strong>右移</strong><ul>\n<li>无符号数采用逻辑移位，有 $u &gt;&gt; k = \\lfloor u / 2^k \\rfloor$</li>\n<li>有符号数采用算术移位，有 $u &gt;&gt; k = \\lceil u / 2^k \\rceil$</li>\n<li>无符号数的右移等价于除以对应2的幂，有符号数不等价（会向错误的方向进位）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"何时使用无符号数？\"><a href=\"#何时使用无符号数？\" class=\"headerlink\" title=\"何时使用无符号数？\"></a>何时使用无符号数？</h3><ul>\n<li>进行模运算时</li>\n<li>当使用bit来表示集合时</li>\n<li>在系统编程中：bit masks、device commands…</li>\n</ul>\n","tags":["csapp"]},{"title":"CSAPP 02 - Floating Point","url":"/2020/11/07/CSAPP-02-Floating-Point/","content":"<p>Notes for Floating Point.</p>\n<a id=\"more\"></a>\n<h3 id=\"二进制小数\"><a href=\"#二进制小数\" class=\"headerlink\" title=\"二进制小数\"></a>二进制小数</h3><p>对于小数</p>\n<script type=\"math/tex; mode=display\">\nb_mb_{m-1} \\dots b_1b_0.b_{-1}b_{-2} \\dots b_{-n-1}b_{-n}</script><p>其中 $b_i$ 取 0 或 1，则其值 $b$ 为</p>\n<script type=\"math/tex; mode=display\">\nb=\\sum_{i=-n}^{m}2^{i} \\cdot b_i</script><p>在编码长度有限的条件下，这种表示法只能表示那些能被写成形如 $x \\cdot 2^y$ 的数。而对于无法写成这种形式的数只能进行近似表示，如 1/5。</p>\n<h3 id=\"IEEE浮点表示\"><a href=\"#IEEE浮点表示\" class=\"headerlink\" title=\"IEEE浮点表示\"></a>IEEE浮点表示</h3><p>一个浮点数 $V$ 表示为</p>\n<script type=\"math/tex; mode=display\">\nV=(-1)^s \\times M \\times 2^E</script><ul>\n<li>$s$ ：符号位，正数为1，负数为0。</li>\n<li>$M$ ：尾数，取值为1 ~ 2 - ε 或 0 ~ 1 - ε 。</li>\n<li>$E$ ：阶码，表示2的E次幂。</li>\n</ul>\n<p>对这三部分进行编码：</p>\n<ul>\n<li>一个单独的符号位直接编码 $s$ 。</li>\n<li>$k$ 位阶码字段 $exp=e_{k-1} \\dots e_1e_0$ 编码 $E$ 。</li>\n<li>$n$ 位小数字段 $frac=f_{n-1} \\dots f_1f_0$ 编码 $M$ 。</li>\n</ul>\n<p>以C语言为例，各部分编码位数如图1</p>\n<center><img src=\"/2020/11/07/CSAPP-02-Floating-Point/1.png\" width=\"75%\"></center>\n\n<center>图1 C语言浮点数编码位数</center>\n\n<p>给定位表示，根据 $exp$ 的值，被编码的值可被分为三种情况，见图2（以单精度为例）</p>\n<center><img src=\"/2020/11/07/CSAPP-02-Floating-Point/2.png\" width=\"75%\"></center>\n\n<center>图2 单精度浮点数分类</center>\n\n<ol>\n<li><p><strong>规格化的</strong></p>\n<p>阶码 $E=e-bias$ ，其中 $e=e_{k-1} \\dots e_1e_0$ 是无符号数，$bias$ 是一个等于 $2^{k-1}-1$ 的偏置值（单精度即127），因此产生的指数范围是 -126 ~ 127。</p>\n<p>尾数 $M=1+f$。</p>\n</li>\n<li><p><strong>非规格化的</strong></p>\n<p>阶码 $E=1-bias$ ，尾数 $M=f$，此时尾数不包含隐含的1。非规格化数提供了浮点0的表示方法。</p>\n</li>\n<li><p><strong>特殊值</strong></p>\n<p>当小数域全为0时，得到的值表示 $\\infty$，根据符号位确定表示的是 $+\\infty$ 还是 $-\\infty$。</p>\n<p>当小数域含有1时，得到的值表示 NaN，例如求 $\\sqrt{-1}$ 就会得到这样的值。</p>\n</li>\n</ol>\n<h3 id=\"舍入\"><a href=\"#舍入\" class=\"headerlink\" title=\"舍入\"></a>舍入</h3><p>当某个数 $x$ 无法用给定精度位数表示需要进行，为其找到一个最近的，能进行浮点表示的数代表它，这就是舍入运算。</p>\n<p>舍入运算会遇到的一个问题是究竟应该向下舍入还是向上舍入，一种方法是同时计算上下界 $x^+$ 和 $x^-$，使得 $x^- \\le x \\le x^+$。</p>\n<p>IEEE浮点格式定义了四种不同的舍入方式</p>\n<ol>\n<li><strong>向偶数舍入：</strong> 4 舍，6 入，5 向偶数。例如 1.5 和 2.5 均舍为 2，3.5 和 4.5 均舍为 4。</li>\n<li><strong>向零舍入：</strong> 正数下舍，负数上舍。</li>\n<li><strong>向上舍入：</strong> ceil</li>\n<li><strong>向下舍入：</strong> floor</li>\n</ol>\n<p>向偶数舍入可以降低平均值计算时的误差，用于找到最接近的匹配。其他三种方法用于计算上下界。</p>\n<p>对于向偶数舍入，在具体操作时，当最低精度位为0时视为偶数，为1时视为奇数。每次舍入都倾向于使得最低精度位变为0。</p>\n<p>例如当最低精度位为四分之一位，即小数点后两位时，$10.11100_2(2 \\frac{7}{8})$ 被舍入到 $11.00_2(3)$。而 $10.10100_2(2 \\frac{5}{8})$ 被舍入到 $10.10_2(2 \\frac{1}{2})$。</p>\n<h3 id=\"浮点运算\"><a href=\"#浮点运算\" class=\"headerlink\" title=\"浮点运算\"></a>浮点运算</h3><p>谨慎地对浮点运算使用<strong>结合律</strong>和<strong>分配律</strong>，尤其是在出现大数运算时。例如如下的程序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a1 = (<span class=\"number\">3.14</span> + <span class=\"number\">1e20</span>) - <span class=\"number\">1e20</span>, a2 = <span class=\"number\">3.14</span> + (<span class=\"number\">1e20</span> - <span class=\"number\">1e20</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f %f\\n%f %f\\n&quot;</span>, a1, a2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//0.000000 3.140000</span></span><br></pre></td></tr></table></figure>\n","tags":["csapp"]},{"title":"CSAPP 03 - Machine-Level Programming","url":"/2021/02/05/CSAPP-03-Machine-Level-Programming/","content":"<p>Notes for Machine-Level Programming.</p>\n<a id=\"more\"></a>\n<h2 id=\"汇编基础\"><a href=\"#汇编基础\" class=\"headerlink\" title=\"汇编基础\"></a>汇编基础</h2><h3 id=\"计算机设计\"><a href=\"#计算机设计\" class=\"headerlink\" title=\"计算机设计\"></a>计算机设计</h3><ul>\n<li><p><strong>指令集架构（ISA）</strong></p>\n<p>为编写机器/汇编代码而需要理解的处理器设计部分<br>如：指令集规范、寄存器</p>\n<blockquote>\n<p>Intel: x86, IA32, Itanium, x86-64<br>ARM: 广泛应用于移动设备<br>RISC V: 一种全新的开源ISA</p>\n</blockquote>\n</li>\n<li><p><strong>微架构</strong></p>\n<p>指令集架构的具体实现<br>如：缓存的大小、核心频率</p>\n</li>\n</ul>\n<h3 id=\"汇编-机器代码\"><a href=\"#汇编-机器代码\" class=\"headerlink\" title=\"汇编/机器代码\"></a>汇编/机器代码</h3><ul>\n<li><p><strong>CPU计算模型</strong></p>\n<center><img src=\"/2021/02/05/CSAPP-03-Machine-Level-Programming/1.png\" width=\"80%\"></center>\n</li>\n<li><p><strong>汇编：数据类型</strong></p>\n<ul>\n<li>1、2、4、8字节的整数（作为数值或地址）</li>\n<li>4、8、10字节的浮点数</li>\n<li>代码：一系列指令构成的字节序列</li>\n<li>没有复合类型如数组、结构体</li>\n</ul>\n<center><img src=\"/2021/02/05/CSAPP-03-Machine-Level-Programming/2.png\" width=\"80%\"></center>\n\n<center>x86-64寄存器</center>\n\n<center><img src=\"/2021/02/05/CSAPP-03-Machine-Level-Programming/3.png\" width=\"80%\"></center>\n\n<center>IA32寄存器</center>\n</li>\n<li><p><strong>汇编：操作</strong></p>\n<ul>\n<li>在寄存器与内存间转移数据（双向）</li>\n<li>在寄存器或内存数据上执行算术操作</li>\n<li>转移控制（无条件跳转进入过程、条件分支、间接分支）</li>\n<li>简单内存地址模式<br><em>mov_ src dest</em><br>movq、movl、movw、movb分别操作8、4、2、1个字节<br>(R): Mem[Reg[R]], movq (%rcx), %rax<br>D(R): Mem[Reg[R]+D], movq 8(%rcx), %rax</li>\n<li>完全内存地址模式<br><em>lea_ src dest</em><br>leaq、leal、leaw、leab分别操作8、4、2、1个字节<br>D(Rb,Ri,S): Mem[Reg[Rb]+S*Reg[Ri]+D], leaq 8(%rdi,%rdi,2), %rax</li>\n<li>其他指令<center><img src=\"/2021/02/05/CSAPP-03-Machine-Level-Programming/4.png\" width=\"60%\"></center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"C-gt-汇编码-gt-机器码\"><a href=\"#C-gt-汇编码-gt-机器码\" class=\"headerlink\" title=\"C -&gt; 汇编码 -&gt; 机器码\"></a>C -&gt; 汇编码 -&gt; 机器码</h3><center><img src=\"/2021/02/05/CSAPP-03-Machine-Level-Programming/5.png\" width=\"80%\"></center>","tags":["csapp"]},{"title":"Google Java Style Guide","url":"/2021/08/25/Google-Java-Style-Guide/","content":"<p>不仅要写代码，还要写一手漂亮的代码</p>\n<a id=\"more\"></a>\n<h3 id=\"术语注释\"><a href=\"#术语注释\" class=\"headerlink\" title=\"术语注释\"></a>术语注释</h3><ol>\n<li><p><em>class(类)</em>，包括所有普通的类(class)、enum、interface或注解类型(<code>@interface</code>)</p>\n</li>\n<li><p><em>member(成员)</em>，包括类中的内部类(静态内部类)、变量、方法、构造方法(除初始化块和注释)</p>\n</li>\n<li><p><em>comment(注释)</em>，指实现时的解释性注释。对于文档注释，使用术语<em>Javadoc</em></p>\n</li>\n</ol>\n<h3 id=\"I-源文件基础\"><a href=\"#I-源文件基础\" class=\"headerlink\" title=\"I. 源文件基础\"></a>I. 源文件基础</h3><ol>\n<li><p>所有源文件都应以UTF-8编码</p>\n</li>\n<li><p>关于空白符</p>\n<ul>\n<li>除行终止符和字面字符串外，源文件中出现的空白符只能是<strong>ascii码为10的水平空格符</strong>。这意味着不应使用tab符做缩进。</li>\n<li>使用转义字符( <code>\\b</code>, <code>\\t</code>, <code>\\n</code>, <code>\\\\</code> )等，而不是对应的八进制(如 <code>\\012</code> )/Unicode(如 <code>\\u000a</code>)转义</li>\n</ul>\n</li>\n<li><p>对于非ascii字符，要么使用实际上的Unicode字符(如 <code>∞</code> )，要么使用对应的Unicode转义(如 <code>\\u221e</code> )。<br>建议使用前一种更方便理解的方法。当不得不使用Unicode转义时最好加上相应的注释</p>\n</li>\n</ol>\n<h3 id=\"II-源文件结构\"><a href=\"#II-源文件结构\" class=\"headerlink\" title=\"II. 源文件结构\"></a>II. 源文件结构</h3><p>每个源文件需要从上至下包含：</p>\n<ol>\n<li><p>License或Copywrite信息</p>\n</li>\n<li><p><code>package</code>声明</p>\n<p><code>package</code>声明不换行</p>\n</li>\n<li><p><code>import</code>声明</p>\n<ul>\n<li>除<code>import static</code>外，其他<code>import</code>声明不使用<code>*</code></li>\n<li><code>import</code>声明不换行</li>\n<li>所有<code>import static</code>声明位于第一个block，其他<code>import</code>声明位于第二个block，两个block间由一行空行分隔。每个block内的<code>import</code>声明按ascii顺序从上到下排列</li>\n<li>不使用<code>import static</code>来导入静态内部类，使用普通的<code>import</code>声明</li>\n</ul>\n</li>\n<li><p>唯一的顶层<code>class</code></p>\n<p>关于<code>class</code>内容的排布：</p>\n<p>决定成员排列先后顺序时应注意遵循某些<strong>逻辑结构</strong>。它们的排布位置对于类的易学性有着很大影响。</p>\n<p>举个反例：将所有新建的方法都被添加到类的最后就不是一个好习惯，因为其破坏了类的逻辑结构。</p>\n<p>另外，所有的<strong>重载</strong>都应处于相邻位置。</p>\n</li>\n</ol>\n<p>每一部分间由一行空行分隔</p>\n<h3 id=\"III-格式\"><a href=\"#III-格式\" class=\"headerlink\" title=\"III. 格式\"></a>III. 格式</h3><ol>\n<li><p>关于大括号</p>\n<ul>\n<li><code>if</code>, <code>else</code>, <code>do</code>, <code>while</code>, <code>for</code>后必须跟大括号，即使该block为空或只有一行</li>\n<li>左括号：前不换行，后换行。右括号：前换行，当结束<strong>方法体、构造方法或一个命名类</strong>后才换行（如<code>else</code>前的右括号就不换行）</li>\n<li>当block为空时，右括号可以不换行直接紧接左括号闭合。除非该block为一个多block声明（如<code>if else</code>）的一部分</li>\n</ul>\n</li>\n<li><p>关于缩进：<strong>每级block前+2空格</strong></p>\n</li>\n<li><p>每行一句statement</p>\n</li>\n<li><p>除特殊情况外，每行<strong>最多100个“字符”</strong>，超出部分需换行。一个“字符”等同于一个Unicode码位，意味着一个全角字符等同于两个“字符”</p>\n</li>\n<li><p>关于4中的换行</p>\n<ul>\n<li><p>换行位置的选择：尽量不要<strong>打破更高的句法层次</strong>。对于非赋值运算符，在运算符之前换行；对于赋值运算符（包括foreach中的<code>:</code>）、逗号<code>,</code>，在运算符之后换行。</p>\n</li>\n<li><p>换行后，<strong>次行缩进在前一行的基础上+4空格</strong></p>\n</li>\n<li><p>当有多个连续行时，当且仅当两行的行首元素在句法上平行时，不需要额外的缩进</p>\n</li>\n</ul>\n</li>\n<li><p>空行</p>\n<ul>\n<li><p>除其他提到的特殊情况外，单空行总是出现在类中连续的成员或初始化块间</p>\n</li>\n<li><p>两个连续的成员变量间不要求一定出现单空行，当需要创建更清晰的逻辑结构时可以添加</p>\n</li>\n<li><p>除以上规则外，在必要时，可以添加单空行提升代码可读性（如将代码分隔为多个逻辑块）</p>\n</li>\n</ul>\n</li>\n<li><p>空格</p>\n<ul>\n<li><p>对于<code>if</code>, <code>for</code>, <code>catch</code>, <code>else</code>等关键字，在它们和括号（包括圆括号和大括号）间添加一个空格</p>\n</li>\n<li><p>在所有左大括号<code>&#123;</code>前添加一个空格，赋值操作除外（如<code>String[][] x = &#123;&#123;\"foo\"&#125;&#125;;</code>）</p>\n</li>\n<li><p>所有二元/三元操作符的前后分别添加一个空格</p>\n</li>\n<li><p>类型转换括号<code>)</code>后添加一个空格</p>\n</li>\n<li><p>类型和变量声明间添加一个空格，如<code>List&lt;String&gt; list</code></p>\n</li>\n</ul>\n</li>\n<li><p>推荐在运算表达式中添加分组括号以更清晰地描述其含义。不要假定所有读代码的人都熟记运算符优先级表</p>\n</li>\n<li><p>特定结构</p>\n<ul>\n<li><p><strong>枚举类</strong><br>每个枚举常量的分隔<code>,</code>后的换行是可选的。当枚举中类中没有声明方法，且枚举常量不含Javadoc时，可以选择使用初始化数组的格式来初始化枚举类。</p>\n</li>\n<li><p><strong>变量声明</strong><br>每次变量声明只指定一个变量。避免类似 <code>int a, b;</code> 的声明方式（for循环内除外）<br>局部变量的声明<strong>应尽可能接近其初次使用位置</strong>，以最小化其作用域。避免在将所有局部变量全部声明在block的开头位置。<br>局部变量的声明往往同时伴随着初始化。如果是较为复杂的初始化，相关代码应紧邻声明位置。</p>\n</li>\n<li><p><strong>数组</strong><br>数组声明允许被编写成block式（即在第一个大括号后换行）。<br>不要使用C风格的数组声明。使用 <code>String[] args</code> 而不是 <code>String args[]</code></p>\n</li>\n<li><p><strong><code>swtich</code></strong></p>\n<p>switch group的起始关键字<code>case</code>, <code>default</code>前使用<strong>+2空格</strong>缩进</p>\n<p>每个switch group内部再<strong>+2空格</strong>缩进</p>\n<p>每个switch group要么立刻结束（使用<code>break</code>, <code>return</code>, 抛出异常等），要么添加注释说明需要执行下一个switch group。通常只要标注即足够。本条规则不适用于最后一个switch group</p>\n<p>每个switch block中必须包含一个 <code>default</code> switch group，即使它不包含任何代码。<br>（对于枚举类型的switch block，如果包含了覆盖到所有可能性的<code>case</code>，可以不添加<code>default</code> switch group）</p>\n</li>\n<li><p><strong>注解</strong></p>\n<p>应用于<strong>类</strong>、<strong>方法</strong>或<strong>构造器</strong>的注解紧邻文档block，且每个注解占据独立的一行。这一行不适用于上述的100字符换行规则</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Nullable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getNameIfPresent</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>应用于<strong>成员变量</strong>的注解紧邻文档block，但多个注解可能被列于同一行，注解间由一个空格分隔</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Partial</span> <span class=\"meta\">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>\n<p>对于方法参数、局部变量、类型的注解编写没有特别要求</p>\n</li>\n<li><p><strong>注释</strong></p>\n<p>对于单行注释，<code>// ...</code> 和 <code>/* ... */</code> 均可</p>\n<p>对于多行注释 <code>/* ... */</code>，随后的每行都应以一个和上一行对齐的 <code>*</code> 开头</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * This is          // And so           /* Or you can</span></span><br><span class=\"line\"><span class=\"comment\"> * okay.            // is this.          * even do this. */</span></span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n<p>不要将注释包含在用星号或其他字符绘制的框中</p>\n</li>\n<li><p><strong>类与成员的修饰关键字</strong></p>\n<p>如出现，按照Java语言规范建议的顺序显示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">default</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">native</span> <span class=\"keyword\">strictfp</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>数字字面量</strong></p>\n<p>声明 <code>long</code> 字面量时，使用 <code>L</code> 后缀而不是 <code>l</code>，避免与 <code>1</code> 混淆</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"III-命名\"><a href=\"#III-命名\" class=\"headerlink\" title=\"III. 命名\"></a>III. 命名</h3><ol>\n<li><p>适用于所有标识符的通用规则</p>\n<p>标识符只能使用ascii字母，数字和下划线（在小部分情况下）。以便于每个有效的标识符名可以被正则表达式的一个<code>\\w+</code>匹配。</p>\n<p>Google不使用特殊前缀、后缀。如 <code>name_</code>, <code>mName</code>, <code>s_name</code> 等不是Google Style</p>\n</li>\n<li><p>按标识符类型</p>\n<ul>\n<li><p><strong>包名</strong></p>\n<p>使用全小写字母，连续的单词直接相连。如使用 <code>com.example.deepspace</code> 而不是 <code>com.example.deepSpace</code> 和 <code>com.example.deep_space</code></p>\n</li>\n<li><p><strong>类名</strong></p>\n<p>使用大写开头的驼峰（<code>UpperCamelCase</code>）</p>\n<p>类名通常为名词或名词词组，如 <code>Character</code> 和 <code>ImmutableList</code> </p>\n<p>接口名词性规则通常和类名一致，但也可以是形容词或形容词词组，如 <code>Readable</code></p>\n<p>测试类名通常以它们所测试的类名开头，以 <code>Test</code> 结束，如 <code>HashTest</code>, <code>HashIntegrationTest</code></p>\n<p>注解类型没有明确的命名规范</p>\n</li>\n<li><p><strong>方法名</strong></p>\n<p>使用小写开头的驼峰（<code>lowerCamelCase</code>）</p>\n<p>方法名通常为动词或动词词组，如 <code>sendMessage</code> 和 <code>stop</code></p>\n<p>下划线可以出现在JUnit的测试方法中，用于分隔方法名的逻辑部分，两部分分别使用驼峰。一种典型的模式是<code>&lt;methodUnderTest&gt;_&lt;state&gt;</code> ，例如 <code>pop_emptyStack</code></p>\n</li>\n<li><p><strong>常量名</strong></p>\n<p>使用下划线分隔的全大写（<code>CONSTANT_CASE</code>）</p>\n<p>常量名通常为名词或名词词组</p>\n<p>常量指那些被 <code>static final</code> 修饰，且<strong>内容完全不可变，自身方法不会改变自身状态</strong>的成员变量。包括所有的原始数据类型、<code>String</code>、不可变类型、以及不可变类型的不可变集合。</p>\n<p>如果某个实例的可观测状态可以改变，则其不是一个常量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Constants</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NUMBER = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class=\"string\">&quot;Ed&quot;</span>, <span class=\"string\">&quot;Ann&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutableMap&lt;String, Integer&gt; AGES = ImmutableMap.of(<span class=\"string\">&quot;Ed&quot;</span>, <span class=\"number\">35</span>, <span class=\"string\">&quot;Ann&quot;</span>, <span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Joiner COMMA_JOINER = Joiner.on(<span class=\"string\">&#x27;,&#x27;</span>); <span class=\"comment\">// because Joiner is immutable</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SomeEnum</span> </span>&#123; ENUM_CONSTANT &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Not constants</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> String nonFinal = <span class=\"string\">&quot;non-final&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">final</span> String nonStatic = <span class=\"string\">&quot;non-static&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;String&gt; mutableCollection = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ImmutableMap&lt;String, SomeMutableType&gt; mutableValues =</span><br><span class=\"line\">    ImmutableMap.of(<span class=\"string\">&quot;Ed&quot;</span>, mutableInstance, <span class=\"string\">&quot;Ann&quot;</span>, mutableInstance2);</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] nonEmptyArray = &#123;<span class=\"string\">&quot;these&quot;</span>, <span class=\"string\">&quot;can&quot;</span>, <span class=\"string\">&quot;change&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>非常量成员变量名</strong></p>\n<p>使用小写开头的驼峰（<code>lowerCamelCase</code>）</p>\n<p>它们的名字通常为名词或名词词组</p>\n</li>\n<li><p><strong>参数名</strong></p>\n<p>使用小写开头的驼峰（<code>lowerCamelCase</code>）</p>\n<p>避免在 <code>public</code> 修饰的方法中使用单字符的参数名</p>\n</li>\n<li><p><strong>局部变量名</strong></p>\n<p>使用小写开头的驼峰（<code>lowerCamelCase</code>）</p>\n<p>即使它们是 <code>final</code> 或不可变的，也不要将它们视作常量，或使用常量的命名风格</p>\n</li>\n<li><p><strong>类型变量名</strong></p>\n<p>可以使用下列两种风格之一</p>\n<ol>\n<li>一个唯一的大写字母，可后跟一个单一的数字，如 <code>T</code> , <code>E</code>, <code>T2</code></li>\n<li>类名风格后跟一个大写字母 <code>T</code>，如 <code>RequestT</code>, <code>FooBarT</code></li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>驼峰标准</p>\n<p>使用下述步骤将一个英语词组转换为驼峰</p>\n<ol>\n<li>去除词组中的所有 <code>&#39;</code> 号，并将其全转换为ascii形式。如 <em>Müller’s algorithm</em> 应该被转换为 <em>Mullers algorithm</em></li>\n<li>将第一步的结果拆分成独立的多个单词。如果结果中已经有驼峰部分，推荐将其进一步拆分成单词。如 <em>AdWords</em> 可以被进一步拆分成 <em>ad words</em></li>\n<li>将所有字母变为小写（包括缩略词），并将每个单词（UpperCamelCase）或除首单词外的每个单词（lowerCamelCase）的第一个字母大写</li>\n<li>连接所有单词，形成最后的驼峰表示</li>\n</ol>\n<p>应用上述的规范化流程可以解决一些专有名词大写导致的不一致。</p>\n<p>如 <em>XML HTTP request</em> 最后应写成 <code>XmlHttpRequest</code> 而不是 <code>XMLHTTPRequest</code></p>\n</li>\n</ol>\n<h3 id=\"IV-编码实践\"><a href=\"#IV-编码实践\" class=\"headerlink\" title=\"IV. 编码实践\"></a>IV. 编码实践</h3><ol>\n<li><p>除重写 <code>@Deprecated</code> 方法外，总是为重写的方法添加 <code>@Override</code> 注解</p>\n</li>\n<li><p>除少数例外情况，对所有被 <code>catch</code> 的Exception都应做出相应响应（通常是记录一条log，或将其向外抛出）</p>\n<ul>\n<li><p>例外1：如确实存在某些不需要处理的情况，需要在 <code>catch</code> block 中添加一条解释性注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = Integer.parseInt(response);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> handleNumericResponse(i);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NumberFormatException ok) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// it&#x27;s not numeric; that&#x27;s fine, just continue</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure></li>\n<li><p>例外2：在某些测试用例中，若 <code>catch</code> 到的Exception变量名以 <code>expected</code> 起始，则可以不添加注释</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  emptyStack.pop();</span><br><span class=\"line\">  fail();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchElementException expected) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>通过类而不是对象来使用静态成员</p>\n</li>\n<li><p>避免使用 Finalizer， 即避免重写 <code>Object.finalize</code> 方法</p>\n</li>\n</ol>\n<h3 id=\"V-Javadoc\"><a href=\"#V-Javadoc\" class=\"headerlink\" title=\"V. Javadoc\"></a>V. Javadoc</h3><ol>\n<li><p>格式</p>\n<p>基本格式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Multiple lines of Javadoc text are written here,</span></span><br><span class=\"line\"><span class=\"comment\"> * wrapped normally...</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">method</span><span class=\"params\">(String p1)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** An especially short bit of Javadoc. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">anotherMethod</span><span class=\"params\">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>当存在空行时，下段段首包含一个 <code>&lt;p&gt;</code> ，后不接空格。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * First paragraph ...</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Second paragraph ...</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Third paragraph</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">method</span><span class=\"params\">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n<p>所有的标准 <code>@</code> tag按 <code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code> 的顺序出现。同时，它们的描述不能为空。</p>\n<p>若某个tag的内容无法包含在一行内，下一行起始位置为本行 <code>@</code> 对齐位置+4空格</p>\n</li>\n<li><p>摘要段</p>\n<p>位于所有Javadoc的<strong>开始段</strong>，用于简要描述当前被注释内容的作用。</p>\n<p>通常为一个名词词组或动词词组，不是一个完整的句子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Correct</span></span><br><span class=\"line\"><span class=\"comment\">/** Returns the customer ID. */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Incorrect</span></span><br><span class=\"line\"><span class=\"comment\">/** This method returns ... */</span></span><br></pre></td></tr></table></figure></li>\n<li><p>在何处使用Javadoc</p>\n<p>除一些例外情况，<strong>至少</strong>为类中的所有的 <code>public</code> 方法、所有 <code>protected</code> , <code>public</code> 成员添加Javadoc</p>\n<ul>\n<li><p>例外1：明显可自解释的方法可以不添加Javadoc，如Getter和Setter。</p>\n<blockquote>\n<p>并不是所有 Getter / Setter 都可以省略Javadoc。例如若某个Getter名为 <code>getCanonicalName</code> 。Javadoc不能仅为一句 <code>/** Returns the canonical name. */</code> ，更不要省略。因为读者可能无法理解 “Canonical Name” 的含义</p>\n</blockquote>\n</li>\n<li><p>例外2：重写的方法允许不添加Javadoc</p>\n</li>\n</ul>\n<p>对于其他不做强制要求的部分，可以不严格遵循上述 1. 中的Javadoc格式。</p>\n<p>另外，对于某些<strong>定义类或成员的总体目的或行为</strong>的实现注释，使用短Javadoc格式，即 <code>/**</code></p>\n</li>\n</ol>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p><a href=\"https://google.github.io/styleguide/javaguide.html\">Google Java Style Guide</a></p>\n<p><a href=\"https://blog.codinghorror.com/new-programming-jargon/\">New Programming Jargon</a></p>\n"},{"title":"How to be a good engineer","url":"/2021/06/17/How-to-be-a-good-engineer/","content":"<p>来自美团技术团队的两篇关于工程师成长的博客</p>\n<a id=\"more\"></a>\n<h3 id=\"写给工程师的十条精进原则\"><a href=\"#写给工程师的十条精进原则\" class=\"headerlink\" title=\"写给工程师的十条精进原则\"></a>写给工程师的十条精进原则</h3><p>本文来自一位工作8年的技术Leader。他总结了自己工作以来犯过的和团队同学犯过的一些错误，并提供了十条帮助工程师解决工作中所遇到问题的原则。</p>\n<ol>\n<li><strong>Owner意识</strong><br>对自己对工作负责、积极主动的推动相关的工作</li>\n<li><strong>时间观念</strong><br>工作要有计划性：做好任务拆解、时间安排外<br>工作要分清主次：运用四象限法</li>\n<li><strong>Begin With The End In Mind</strong><br>开始一件事情前一定要带着明确的目标，设立事情的边界<br>同样适用于技术学习</li>\n<li><p><strong>闭环思维</strong></p>\n<blockquote>\n<p>真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。</p>\n</blockquote>\n<p>凡事有交代，保持反馈 </p>\n</li>\n<li><strong>保持敬畏</strong><br>对组内规章制度的遵循，包括编码规范、上线流程等<br>如果认为某些制度有问题，可以提出来和组内同事一起讨论，看是否可以优化</li>\n<li><strong>事不过二</strong><br>作者组内的评审和问题讨论不超过两次<br>通过设置强制性的原则提高相关环节的效率，减少无意义的内耗，保证每次的沟通都是有效的</li>\n<li><strong>设计优先</strong><br>重视设计文档的编写。良好的设计可以保证系统开发的可持续。</li>\n<li><strong>P/PC平衡</strong><br>即产出/产能平衡<br>在保证工作产出的同时应保证自身的良性发展（技术沉淀、身体健康、软实力）</li>\n<li><strong>善于提问</strong><br>不要想当然，不要怕麻烦他人，多问是提高工作效率的一大利器</li>\n<li><strong>空杯心态</strong><br>时刻保持谦虚，从不同位置的同事处了解自己的问题</li>\n</ol>\n<h3 id=\"工作中如何做好技术积累\"><a href=\"#工作中如何做好技术积累\" class=\"headerlink\" title=\"工作中如何做好技术积累\"></a>工作中如何做好技术积累</h3><ul>\n<li><strong>学习的原则</strong><br>坚持 + 实践 + 交流 + 总结输出<br>做好规划。关于短期规划，需要设立一个基本时间单位（如一个月），按基本时间单位进行规划。规划时为每个目标设定下限，再具体到更细粒度的时间单位（如安排10天学习，10天旅行等）。逐层拆解，直到划分到每个任务可以较为轻松地完成。长期规划遵循三点：远离夕阳行业、跟随自己的兴趣、做好积累、边走边看，及时调整规划。</li>\n<li><strong>工作中的困惑</strong><ol>\n<li>知识是学不完的，因此学习时要抓住核心，把根本学精。例如许多加密技术最终源自素因数分解难题；从多核多CPU多线程到多机房，一致性问题最终都可归结到Paxos中的各种理论。相比“术”更应重视“道”。</li>\n<li>不要过于重技术、轻业务。基础技术并不一定就比业务团队高级，技术最终是服务于业务的。</li>\n<li>重视沟通技巧，通过提前沟通、抓住主题来努力实现有效沟通。</li>\n<li>时刻关注效率的提升，要有清晰的结果导向思维。</li>\n</ol>\n</li>\n<li><strong>架构师需要的能力</strong><br>L4: 团队管理能力<br>L3: 项目管理能力 在线运维能力<br>L2: 架构能力 性能优化能力<br>L1: 编程能力 调试能力 编译部署能力<br>上面的能力中层级越低的越基础，上层能力依赖下层能力</li>\n</ul>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"https://tech.meituan.com/2018/08/16/10-principles-for-engineers.html\">美团技术团队：写给工程师的十条精进原则</a></li>\n<li><a href=\"https://tech.meituan.com/2018/04/16/study-vs-work.html\">美团技术团队：工作中如何做好技术积累</a></li>\n</ul>\n"},{"title":"INT_MAX和INT_MIN","url":"/2020/04/03/INT-MAX%E5%92%8CINT-MIN/","content":"<p>今天Leetcode的每日一题是实现一个atoi函数，其中要求当参数大于INT_MAX或小于INT_MIN时返回INT_MAX或INT_MIN。做题时突然发现自己对如何通过位运算得到INT_MAX和INT_MIN还一知半解，因此决定探索一下。</p>\n<a id=\"more\"></a>\n<h3 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h3><ul>\n<li><p><strong>int在C/C++中的字节数</strong></p>\n<p>int具体所占的字节数和平台有关，标准的说法是不短于short，不长于long。在目前使用的大部分平台中通常都是4个字节，即32位。因此本文按32位分析。</p>\n</li>\n<li><p><strong>原码</strong></p>\n<p>最高位是符号位，0表示正，1表示负，其他位是数字的绝对值的二进制。</p>\n<p>例如：</p>\n<p>1 的原码：00000000 00000000 00000000 00000001</p>\n<p>-1 的原码：10000000 00000000 00000000 00000001</p>\n</li>\n<li><p><strong>反码</strong></p>\n<p>正数的反码与原码一致，负数的反码在原码的基础上保持符号位不变，其他位按位取反。</p>\n<p>例如：</p>\n<p>-1 的反码：11111111 11111111 11111111 11111110</p>\n</li>\n<li><p><strong>补码</strong></p>\n<p>正数的补码与原码一致，负数的补码是其<strong>反码加1</strong>。</p>\n<p>例如：</p>\n<p>-1 的补码：11111111 11111111 11111111 11111111</p>\n</li>\n</ul>\n<h3 id=\"INT-MAX和INT-MIN的值\"><a href=\"#INT-MAX和INT-MIN的值\" class=\"headerlink\" title=\"INT_MAX和INT_MIN的值\"></a>INT_MAX和INT_MIN的值</h3><p>计算机中的数字都使用补码表示，原因是为了“化减为加”，只需要实现一个加法器就可以同时完成加和减两种运算。int是带符号整数，只有31位可以表示数字，因此就可以得到</p>\n<p><strong>INT_MAX：</strong> 01111111 11111111 11111111 11111111，即 $2^{31}-1$</p>\n<p><strong>INT_MIN：</strong> 10000000 00000000 00000000 00000000，即 $-2^{31}$</p>\n<p>以上均为补码表示，注意到INT_MIN的原码和补码是一致的，且从原码的定义看，INT_MIN应该表示“负0”才对，但由于我们不需要两个0，因此人为规定补码10000000 00000000 00000000 00000000表示 $-2^{31}$。</p>\n<p>同时根据补码的运算规则可以发现的一个规律是：</p>\n<script type=\"math/tex; mode=display\">\nINT\\_MAX = INT\\_MIN-1</script><p>同理：</p>\n<script type=\"math/tex; mode=display\">\nINT\\_MIN = INT\\_MAX+1</script><h3 id=\"INT-MAX和INT-MIN的获得\"><a href=\"#INT-MAX和INT-MIN的获得\" class=\"headerlink\" title=\"INT_MAX和INT_MIN的获得\"></a>INT_MAX和INT_MIN的获得</h3><p>有了上面的分析，就可以定义INT_MAX和INT_MIN了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：16进制硬编码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INT_MAX = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INT_MIN = <span class=\"number\">0x80000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法二：利用无符号整型和公式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INT_MAX = ((<span class=\"keyword\">unsigned</span>)(<span class=\"number\">-1</span>)) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INT_MIN = INT_MAX + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法三：climits/limitis.h头文件中已定义，可直接使用</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Java笔记-（1）面向对象","url":"/2020/09/30/Java%E7%AC%94%E8%AE%B0-%EF%BC%881%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"<p>Java面向对象的一些关键知识</p>\n<a id=\"more\"></a>\n<h3 id=\"面向对象的四个特征\"><a href=\"#面向对象的四个特征\" class=\"headerlink\" title=\"面向对象的四个特征\"></a>面向对象的四个特征</h3><ul>\n<li><strong>抽象：</strong> 提取出一类事物的共有属性和行为。</li>\n<li><strong>封装：</strong> 把抽象出的数据和行为封装在一起，供程序其他部分有权限地使用。</li>\n<li><strong>继承：</strong> 在已有结果基础上继续进行功能的扩充</li>\n<li><strong>多态：</strong> 同一类型的同一行为在不同情况下可以表现出不同的状态。</li>\n</ul>\n<h3 id=\"权限关键字\"><a href=\"#权限关键字\" class=\"headerlink\" title=\"权限关键字\"></a>权限关键字</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>访问权限</th>\n<th>本类</th>\n<th>本包的类</th>\n<th>子类</th>\n<th>非子类的外包类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>public</strong></td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td><strong>protected</strong></td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td><strong>default</strong></td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td><strong>private</strong></td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><ul>\n<li>方法名与类名相同，没有返回值类型</li>\n<li>用于初始化对象属性</li>\n<li>在使用new语句时被调用</li>\n<li>不显示声明时，在编译时会为类自动加上一个无参的空构造方法</li>\n<li>可通过重载实现多个接受不同参数的构造方法</li>\n<li>显示声明时，将不再自动添加无参空构造方法</li>\n<li>可在构造方法中使用 <code>this(...)</code> 调用其他构造方法，且该语句应放在方法的第一行。</li>\n<li>保留无参空构造方法是一个好习惯（某些框架可依其通过反射创建对象）</li>\n<li>private修饰的构造方法可用于实现单例模式</li>\n</ul>\n<h3 id=\"值传递与引用传递\"><a href=\"#值传递与引用传递\" class=\"headerlink\" title=\"值传递与引用传递\"></a>值传递与引用传递</h3><p><strong>Java中只存在值传递</strong>。Java中包含两类数据类型：</p>\n<ol>\n<li><strong>基本类型</strong><ul>\n<li>byte</li>\n<li>short</li>\n<li>int</li>\n<li>long</li>\n<li>float</li>\n<li>double</li>\n<li>char</li>\n<li>boolean</li>\n</ul>\n</li>\n<li><strong>引用类型，其值表示一个地址</strong><ul>\n<li>类</li>\n<li>接口</li>\n<li>数组</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><ul>\n<li>Java中的继承是单继承</li>\n<li>子类可以拥有父类非private的成员</li>\n<li>子类可以定义自己的成员，对父类进行扩展</li>\n<li>子类可以<strong>重写</strong>父类的方法（多态的实现）</li>\n<li>子类不能继承父类的构造方法，但可以通过 <code>super(...)</code> 调用父类的构造方法</li>\n<li>子类会调用父类的默认构造方法，但若默认构造方法不存在，则必须显式地通过 <code>super</code> 调用父类的构造方法，且该语句必须位于子类构造方法的第一行</li>\n</ul>\n<h3 id=\"对象初始化顺序\"><a href=\"#对象初始化顺序\" class=\"headerlink\" title=\"对象初始化顺序\"></a>对象初始化顺序</h3><ol>\n<li>父类静态字段初始化、父类静态代码块（取决于二者声明的先后顺序）</li>\n<li>子类静态字段初始化、子类静态代码块（取决于二者声明的先后顺序）</li>\n<li>父类普通字段初始化</li>\n<li>父类构造代码块</li>\n<li>父类构造方法</li>\n<li>子类普通字段初始化</li>\n<li>子类构造代码块</li>\n<li>子类构造方法</li>\n</ol>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li>定义类时使用abstract修饰</li>\n<li>抽象类可以有构造方法、属性、方法实现</li>\n<li>抽象类可以没有抽象方法，但存在抽象的方法一定要定义为抽象类</li>\n<li>非抽象类继承抽象类时需要实现所有抽象方法</li>\n<li>抽象类继承抽象类时可以不实现父类抽象方法</li>\n<li>抽象类不能被实例化</li>\n<li>抽象类不能用final修饰</li>\n</ul>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><ul>\n<li>使用interface定义</li>\n<li>接口可以继承其他<strong>多个</strong>接口</li>\n<li>类可以实现<strong>多个</strong>接口</li>\n<li>抽象类实现接口时可以不实现接口的方法</li>\n<li>接口不能有构造方法</li>\n<li>接口不能被实例化</li>\n<li><p>接口中可以定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Interface1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实际为 public static final int CONSTANT = 10;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> CONSTANT = <span class=\"number\">10</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 实际为 public abstract void abstractMethod();</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">abstractMethod</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">defaultMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Default Implementation&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Static Method&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p><strong>常量</strong></p>\n<p>如CONSTANT的定义所示。<strong>可以被继承</strong>。接口中定义的所有属性默认用public static final修饰，这些关键字可以省略。当实现类中出现命名冲突时，可以使用 <code>Interface1.CONSTANT</code> 使用接口中的常量。</p>\n</li>\n<li><p><strong>抽象方法</strong></p>\n<p>如abstractMethod的定义所示。接口中定义的无实现方法默认使用public abstract修饰，这些关键字可以省略。实现接口时需要重写接口中的所有抽象方法。</p>\n</li>\n<li><p><strong>默认实现方法（JDK 1.8及以后）</strong></p>\n<p>如defaultMethod的定义所示。默认实现方法存在方法体，在实现接口时可以不重写这些方法。但若实现类实现了多个接口，且这些接口中存在同名的默认实现方法，实现类中就必须重写重名的默认实现方法。</p>\n<p>默认实现方法必须通过接口的实现类来调用，如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Interface1Impl().defaultMethod();</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>静态方法（JDK1.8及以后）</strong></p>\n<p>如staticMethod的定义所示。<strong>不可以被继承</strong>。接口中的静态方法必须通过接口名访问，如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Interface1.staticMethod();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><ul>\n<li><p><strong>成员内部类</strong></p>\n<ul>\n<li>定义为外部类的一个成员</li>\n<li>成员内部类对象依赖外部类对象而存在，在创建成员内部类对象前需要先创建其外部类对象</li>\n<li>成员内部类中使用 <code>this</code> 访问自身的属性和方法，使用 <code>外部类名.this</code> 访问其外部类中的属性和方法</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Outer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer: &quot;</span>+a1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Inner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            a1=<span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 访问外部类的属性</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Inner.Outer: &quot;</span>+Outer.<span class=\"keyword\">this</span>.a1);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 访问自身的属性</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Inner: &quot;</span>+a1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在外部类中实例化内部类对象</span></span><br><span class=\"line\">        Inner inner = <span class=\"keyword\">new</span> Inner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在外部类外部实例化内部类对象</span></span><br><span class=\"line\">        Outer.Inner inner = outer.<span class=\"function\">new <span class=\"title\">Inner</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Outer: 10</span></span><br><span class=\"line\"><span class=\"comment\">Inner.Outer: 10</span></span><br><span class=\"line\"><span class=\"comment\">Inner: 100</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>静态内部类</strong></p>\n<ul>\n<li>如同类的其他静态成员，在没有外部类对象时，可以使用 <code>外部类名.内部类名</code> 来使用静态内部类</li>\n<li>静态内部类中无法访问外部类的非静态成员</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Outer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        a2 = <span class=\"number\">11</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Outer: &quot;</span>+a2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StaticInner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StaticInner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            a2=<span class=\"number\">111</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 访问外部类的静态属性</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Inner.Outer: &quot;</span>+Outer.a2);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 访问自身的属性</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Inner: &quot;</span>+a2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在外部类中实例化内部类对象</span></span><br><span class=\"line\">        StaticInner inner = <span class=\"keyword\">new</span> StaticInner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在外部类外部实例化内部类对象</span></span><br><span class=\"line\">        Outer.StaticInner inner = <span class=\"keyword\">new</span> Outer.StaticInner();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Outer: 11</span></span><br><span class=\"line\"><span class=\"comment\">Inner.Outer: 11</span></span><br><span class=\"line\"><span class=\"comment\">Inner: 111</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>局部内部类</strong></p>\n<ul>\n<li>定义在外部类的<strong>方法/代码块</strong>中</li>\n<li>局部内部类不能有静态成员</li>\n<li>局部内部类中可以使用 <code>外部类名.this</code> 访问其外部类中的属性和方法，但外部类不能访问局部内部类中定义的成员</li>\n<li>局部内部类只能在定义域内被实例化</li>\n<li><p>JDK 1.8以前，局部内部类对象不能使用该内部类所在方法的非 <code>final</code> 局部变量</p>\n<blockquote>\n<p>当调用方法时，局部变量如果没有用final修饰，其生命周期和方法的生命周期是一样的。方法被调用时会入栈，方法结束后即弹栈，这个局部变量也会消失。那么如果局部内部类对象还没有马上消失想用这个局部变量，显然已无法使用了。用final修饰的变量会在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也就可以继续使用了。</p>\n<p>JDK 1.8及以后编译器会自动为被局部内部类使用的局部变量加上final关键字修饰。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>匿名内部类</strong></p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名或接口名() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 重写或定义方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>是局部内部类的延伸，所有局部内部类的限制都对其生效</li>\n<li>一定跟在 <code>new</code> 后面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><ul>\n<li>多态分为<strong>方法的重写与重载</strong>和<strong>对象的多态性</strong>两部分</li>\n<li>父类引用可以指向子类对象，自动转换（向上转型）</li>\n<li>子类引用指向父类对象时需要强制转换（向下转型）</li>\n<li>实现多态的三个必要条件：<strong>继承、重写、向上转型</strong><ul>\n<li><strong>继承：</strong> 在多态中需要存在有继承关系的父类和子类</li>\n<li><strong>重写：</strong> 子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>\n<li><strong>向上转型：</strong> 父类的引用指向父类对象时，调用的是父类中定义的方法；指向子类对象时，调用的是子类中定义的方法。</li>\n</ul>\n</li>\n<li>将接口的引用指向不同的实现该接口的类实例可以实现基于接口的多态</li>\n</ul>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li><p><strong>this</strong></p>\n<ul>\n<li>指向当前对象的引用</li>\n<li>调用属性：<code>this.属性名</code> ，可用于解决成员变量名和局部变量名冲突</li>\n<li>调用方法：<code>this.方法名(...)</code></li>\n<li>调用构造方法：<code>this(...)</code> ，只能用于构造方法中，且作为方法的第一条语句</li>\n</ul>\n</li>\n<li><p><strong>super</strong></p>\n<ul>\n<li>指向父类的引用</li>\n<li>调用父类的属性：<code>super.属性名</code> ，可用于访问被子类隐藏的父类属性</li>\n<li>调用父类的方法：<code>super.方法名(...)</code></li>\n<li>调用父类的构造方法：<code>super(...)</code> ，若父类的默认构造方法不存在，则在子类构造方法中必须使用这种方法显式地调用父类的构造方法，且作为方法的第一条语句</li>\n</ul>\n</li>\n<li><p><strong>static</strong></p>\n<ul>\n<li>可修饰属性、方法、代码块，表示当前修饰的成员为静态的</li>\n<li>通过 <code>类名.属性名（或方法名）</code> 调用</li>\n<li>静态属性、静态方法属于类，而不是对象</li>\n<li>静态属性按照定义顺序初始化</li>\n<li>静态方法内不可使用 <code>this</code> 和 <code>super</code> 关键字</li>\n<li>静态方法内不可使用非静态成员，但非静态方法内部可以使用静态成员</li>\n<li>静态代码块在类初次加载时被调用</li>\n</ul>\n</li>\n<li><p><strong>final</strong></p>\n<ul>\n<li>修饰属性，表示声明一个常量</li>\n<li>修饰方法，表示该方法无法被重写</li>\n<li>修饰类，表示该类无法被继承</li>\n<li>修饰方法参数，在方法内部不能修改参数的值</li>\n</ul>\n</li>\n<li><p><strong>abstract</strong></p>\n<ul>\n<li>修饰类时表示该类为抽象类<br><em>细节见 &lt;抽象类&gt;</em></li>\n<li>修饰方法时表示该方法为抽象方法<ol>\n<li>只有声明，没有实现</li>\n<li>抽象方法不能用private修饰，因为子类无法重写</li>\n<li>抽象方法不能用static修饰</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>instanceof</strong></p>\n<ul>\n<li>用于检查对象是否为某个类的实例</li>\n<li><p>通常在把父类引用强制转为子类引用时使用，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object obj = ... ;<span class=\"comment\">// 从某个方法中获得一个Object类型引用</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> Integer) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n","tags":["java"]},{"title":"Java笔记-（2）Object类","url":"/2020/10/20/Java%E7%AC%94%E8%AE%B0-%EF%BC%882%EF%BC%89Object%E7%B1%BB/","content":"<p>Object类是Java中所有类的基类。定义的任何类都会默认继承Object类。Object类中有一系列重要的方法。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-getClass\"><a href=\"#1-getClass\" class=\"headerlink\" title=\"1. getClass\"></a>1. getClass</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>\n<p>返回该对象运行时类的Class对象。Class对象记录了类的信息，包括属性、方法。被 <code>static synchronized</code> 修饰的方法锁住的即为该对象。</p>\n<h3 id=\"2-hashCode\"><a href=\"#2-hashCode\" class=\"headerlink\" title=\"2. hashCode\"></a>2. hashCode</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>返回该对象的一个hash值，该方法支持着各类哈希表的实现，如 <code>HashMap</code> 。</p>\n<p>Object对该方法的默认实现是将对象的内部地址转换为一个整形值。</p>\n<p>该方法的重写约定包括：</p>\n<ol>\n<li>Java应用程序执行期间多次对同一个对象调用 <code>hashCode</code> 方法时，只要没有修改在对象 <code>equals</code> 方法比较中使用的信息，该方法就必须一致地返回相同的整数。但不要求同一应用程序在不同的执行中返回相同的值。</li>\n<li>若根据 <code>equals(Object)</code> 方法得到两个对象相等，则两个对象的 <code>hashCode</code> 需要返回相同的值。</li>\n<li>若根据 <code>equals(Object)</code> 方法得到两个对象不相等，并不要求两个对象的 <code>hashCode</code> 一定要返回不同的值。但设计时最好降低二者 <code>hashCode</code> 返回相同值的概率，这样可以提高哈希表的性能。</li>\n</ol>\n<h3 id=\"3-equals\"><a href=\"#3-equals\" class=\"headerlink\" title=\"3. equals\"></a>3. equals</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回某个对象是否和当前对象“相等”。该方法实现了一个非空对象引用的等级关系。即</p>\n<ol>\n<li>自反性：对于任何非空引用 <code>x</code> ，<code>x.equals(x)</code> 始终为true</li>\n<li>对称性：对于任何非空引用 <code>x</code> ，<code>x.equals(y)</code> 和 <code>y.equals(x)</code> 同真假</li>\n<li>传递性：对于任何非空引用 <code>x</code> ，若 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 为true，则 <code>x.equals(z)</code> 为true</li>\n<li>一致性：对于任何非空引用 <code>x</code> ，假设 <code>equals</code> 方法中用到的信息不被修改，则对 <code>x.equals(y)</code> 的多次调用应始终返回相同的值</li>\n<li>对于任何非空引用 <code>x</code> ，<code>x.equals(null)</code> 应始终返回false</li>\n</ol>\n<h3 id=\"4-clone\"><a href=\"#4-clone\" class=\"headerlink\" title=\"4. clone\"></a>4. clone</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">native</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>\n<p>返回当前对象的一个拷贝对象。若类未实现 <code>Clonealbe</code> 接口会抛出 <code>CloneNotSupportedException</code> ，否则返回当前对象的一个<strong>浅拷贝</strong>，即新建一个对象，并简单地将当前对象所有属性的值赋给新对象。此外，所有数组类型 <code>T[]</code> 默认实现了 <code>Clonealbe</code> 接口，无论 <code>T</code> 是基本类型还是引用类型。</p>\n<h3 id=\"5-toString\"><a href=\"#5-toString\" class=\"headerlink\" title=\"5. toString\"></a>5. toString</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getName() + <span class=\"string\">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回当前对象的字符串表示。建议在所有子类中重写它。</p>\n<h3 id=\"6-notify\"><a href=\"#6-notify\" class=\"headerlink\" title=\"6. notify\"></a>6. notify</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>唤醒等待该对象monitor的一个线程。若有多个线程在等待，则会选择其中一个。选择是任意的，由实现自行决定。</p>\n<p>在当前线程释放该对象的monitor之前，被唤醒的线程将无法继续执行。</p>\n<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）</strong></p>\n<p>一个线程可以通过三种方式获取对象的monitor。</p>\n<ol>\n<li>通过执行一个对象的由 <code>synchronized</code> 修饰的实例方法</li>\n<li>通过执行被 <code>synchronized</code> 修饰的代码块，且 <code>synchronized</code> 锁住的是当前对象</li>\n<li>对于Class类对象，通过执行该类被  <code>static synchronized</code> 修饰的方法</li>\n</ol>\n<p>一个对象的monitor在一个时刻只能被一个线程持有。</p>\n<h3 id=\"7-notifyAll\"><a href=\"#7-notifyAll\" class=\"headerlink\" title=\"7. notifyAll\"></a>7. notifyAll</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyAll</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>唤醒所有等待该对象monitor的线程。</p>\n<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）</strong></p>\n<h3 id=\"8-wait\"><a href=\"#8-wait\" class=\"headerlink\" title=\"8. wait\"></a>8. wait</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\twait(<span class=\"number\">0L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis, <span class=\"keyword\">int</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeoutMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;timeoutMillis value is negative&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nanos &lt; <span class=\"number\">0</span> || nanos &gt; <span class=\"number\">999999</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</span><br><span class=\"line\">                <span class=\"string\">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nanos &gt; <span class=\"number\">0</span> &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) &#123;</span><br><span class=\"line\">        timeoutMillis++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    wait(timeoutMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使当前对象所在的线程进入等待状态，直到其他线程调用该对象的 <code>notify</code> 或 <code>notifyAll</code> 方法，或等待指定的时间。</p>\n<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）。</strong></p>\n<p>该方法会使当前线程将自身加入对象的等待集，然后放弃此对象上的任何同步声明。在以下四种情况发生前，当前线程将保持休眠，不参与线程调度。</p>\n<ol>\n<li>其他线程调用对象的 <code>notify</code> 方法且当前线程正好被选中唤醒</li>\n<li>其他线程调用对象的 <code>notifyAll</code> 的方法</li>\n<li>其他线程调用当前线程的 <code>interrupt</code> 方法</li>\n<li>经过指定的等待时间。若指定时间为0，则表示等待无限长时间，只能被其他三种方法唤醒。</li>\n</ol>\n<p>达到触发条件后，当前线程将从对象的等待集中移除，并重新参与线程调度以及和其他线程对<strong>该对象</strong>的竞争。</p>\n<p>注意，当wait方法将当前线程放入该对象的等待集时，它只解锁该对象。在线程等待时，当前线程上可能被同步的任何其他对象将保持锁定。</p>\n<h3 id=\"9-finalize\"><a href=\"#9-finalize\" class=\"headerlink\" title=\"9. finalize\"></a>9. finalize</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>当垃圾收集确定没有对对象的更多引用时，由垃圾收集器在对象上调用。子类可以重写finalize方法来释放系统资源或执行其他清理。</p>\n<p><code>finalize</code> 方法中可以采取任何措施，包括使该对象再次对其他线程可用。但通常情况下，<code>finalize</code> 方法的作用是在该对象被无法恢复地销毁前执行一些清除操作，例如释放一些非Java资源（打开的文件、数据库连接）或调用非Java方法时分配的内存（C的malloc）。由于GC的不确定性，<code>finalize</code> 的调用时机也是不确定的。即，从一个对象变得不可达，到其 <code>finalize</code> 方法被调用，这期间经历的时间不确定，因此不要过于依赖 <code>finalize</code> 来完成资源回收，很可能在 <code>finalize</code> 被调用前资源就已耗尽。最好的方法是当不再需要分配给对象的资源时，在业务代码中就进行释放操作。</p>\n<p>Java不能保证由哪个线程来调用给定对象的 <code>finalize</code> 方法。但可以保证的是，在调用 <code>finalize</code> 时，调用线程将不持有任何用户可见的同步锁。如果 <code>finalize</code> 方法抛出未捕获的异常，则该异常将被忽略，并且该对象的终结将终止。</p>\n<p><strong><code>finalize</code> 方法最多只会被调用一次。</strong></p>\n<p>Object对象的 <code>finalize</code> 方法不执行任何特殊操作，它只是正常返回。Object的子类可以重写该方法。</p>\n","tags":["java"]},{"title":"LRU和LFU","url":"/2020/04/06/LRU%E5%92%8CLFU/","content":"<h2 id=\"缓存淘汰算法\"><a href=\"#缓存淘汰算法\" class=\"headerlink\" title=\"缓存淘汰算法\"></a>缓存淘汰算法</h2><p>缓存是为了解决存储介质间读写速度相差过大而设置的一块大小有限的数据缓存区。经由缓存中转，可极大地提高数据的读写速度，从而提高系统性能。由于缓存大小有限，当存储的数据达到其大小限制时就需要淘汰掉其中一部分“价值最小”的数据，从而使其可以装入新的数据。这就是<strong>缓存淘汰算法</strong>的工作。缓存淘汰算法在计算机科学中应用十分广泛，从最底层的硬件到最上层的应用层都有着它的身影。例如缓和CPU和内存间速度差异的Cache，操作系统层的虚拟内存，应用层的缓存中间件等等。不同的评判数据价值的方式催生了不同的缓存淘汰算法，常见的有FIFO、LRU、LFU等。本文将结合两道题目分析LRU和LFU两种缓存淘汰算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>LRU的全称是<strong>Least Recently Used</strong>，即最近最少使用。该算法认为最近最少使用的数据块是“最没有价值的”，因此在每次缓存满时淘汰它。</p>\n<p>举个例子，当缓存容量为3，数据序列为 2 1 2 1 2 3 4 时，被淘汰的数据是1。</p>\n<h3 id=\"Leetcode-146-LRU缓存机制\"><a href=\"#Leetcode-146-LRU缓存机制\" class=\"headerlink\" title=\"Leetcode 146-LRU缓存机制\"></a>Leetcode 146-LRU缓存机制</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>\n<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>\n<p><strong>进阶：</strong></p>\n<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class=\"line\"></span><br><span class=\"line\">cache.put(1, 1);</span><br><span class=\"line\">cache.put(2, 2);</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class=\"line\">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class=\"line\">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class=\"line\">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class=\"line\">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>利用<strong>双向链表+哈希表</strong>实现。维护一个由value节点链成的双向链表和一个从key到value节点的哈希表。</p>\n<ul>\n<li><p><strong>get</strong></p>\n<p>首先检查哈希表，看key是否存在，若不存在直接返回-1。若存在，将当前value节点从链表中删除，再插入到链表头，最后返回value。</p>\n</li>\n<li><p><strong>put</strong></p>\n<p>首先直接调用get方法检查哈希表，看key是否已存在。若存在，经过get方法，value节点已经到达表头，只需要更新value的值即可。若不存在，则需要在链表中插入新节点。插入前需要先检查链表中的元素数是否已经等于capacity。若是，链表尾元素就是最近最少使用的元素，淘汰即可。之后再将新节点插入到链表头。最后将映射关系加入哈希表。</p>\n</li>\n</ul>\n<p>get和put的时间复杂度均为 <script type=\"math/tex\">O(1)</script> 。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node pre;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = k;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Node tail;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;Integer, Node&gt; hash;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Node cur = hash.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        Node pre = cur.pre, next = cur.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 说明cur不为head，将其放于head</span></span><br><span class=\"line\">            pre.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                next.pre = pre;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                tail = pre;</span><br><span class=\"line\">            cur.next = head;</span><br><span class=\"line\">            head.pre = cur;</span><br><span class=\"line\">            cur.pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            head = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.get(key) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            hash.get(key).value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Node cur = <span class=\"keyword\">new</span> Node(key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 新节点都插入为head</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = tail = cur;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            cur.next = head;</span><br><span class=\"line\">            head.pre = cur;</span><br><span class=\"line\">            head = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hash.size() == capacity) &#123; <span class=\"comment\">//若已达容量删除tail</span></span><br><span class=\"line\">            hash.remove(tail.key);</span><br><span class=\"line\">            tail = tail.pre;</span><br><span class=\"line\">            tail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash.put(key, cur);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"LFU\"><a href=\"#LFU\" class=\"headerlink\" title=\"LFU\"></a>LFU</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>LFU的全称是<strong>Least Frequently Used</strong>，即最不常使用。该算法在选择淘汰的数据块时以其使用次数为依据，使用次数最少的将被淘汰。</p>\n<p>还是使用LRU的例子，缓存容量为3，数据序列为 2 1 2 1 2 3 4 ，LFU中被淘汰的数据是3。</p>\n<h3 id=\"Leetcode-460-LFU缓存\"><a href=\"#Leetcode-460-LFU缓存\" class=\"headerlink\" title=\"Leetcode 460-LFU缓存\"></a>Leetcode 460-LFU缓存</h3><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。</p>\n<p>get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。<br>put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。</p>\n<p><strong>进阶：</strong><br>你是否可以在 <strong>O(1)</strong> 时间复杂度内执行两项操作？</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">LFUCache cache &#x3D; new LFUCache( 2 &#x2F;* capacity (缓存容量) *&#x2F; );</span><br><span class=\"line\"></span><br><span class=\"line\">cache.put(1, 1);</span><br><span class=\"line\">cache.put(2, 2);</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">cache.put(3, 3);    &#x2F;&#x2F; 去除 key 2</span><br><span class=\"line\">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到key 2)</span><br><span class=\"line\">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class=\"line\">cache.put(4, 4);    &#x2F;&#x2F; 去除 key 1</span><br><span class=\"line\">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到 key 1)</span><br><span class=\"line\">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class=\"line\">cache.get(4);       &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>\n<h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>采用和LRU相似的思路，我们希望在淘汰操作时所有节点也可以按淘汰顺序形成一个列表，待淘汰的元素位于表头。LFU中根据使用频率来决定淘汰的节点，每次淘汰使用频率最少的那个。当多个节点频率值相同时，再采用LRU来淘汰节点。因此，最终我们需要的列表应该是这样的：使用频率从头到尾依次增大，使用频率相等时，使用时间戳从头到尾依次增大。这样一个序列我们可以通过一颗<strong>平衡二叉树</strong>实现，在Java中，使用TreeSet即可。此外，为了获取到value节点，仍然需要一个<strong>哈希表</strong>。</p>\n<ul>\n<li><p><strong>get</strong></p>\n<p>首先检查哈希表，看key是否存在，若不存在直接返回-1。若存在，先将value节点从TreeSet中移除，更新其使用频率和时间戳，再将其重新插入TreeSet中，最后返回value。</p>\n</li>\n<li><p><strong>put</strong></p>\n<p>首先直接调用get方法检查哈希表，看key是否已存在。若存在，经过get方法，value节点已经到达树中的新位置，只需要更新value的值即可。若不存在，则需要在链表中插入新节点。插入前需要先检查TreeSet中的元素数是否已经等于capacity。若是，树中最左端的元素就是需要淘汰的元素。可调用pollFirst方法获取。之后再将新节点插入到TreeSet中。最后将映射关系加入哈希表。</p>\n</li>\n</ul>\n<p>由于get和put操作中都需要对平衡二叉树进行插入删除操作，因此二者的最终时间复杂度均为 <script type=\"math/tex\">O(lgn)</script>。还可以使用双链表实现真正的 <script type=\"math/tex\">O(1)</script> 。（有机会再补</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LFUCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Node</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> freq;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> time;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = k;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = v;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.time = t;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.freq = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Node n)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.freq &lt; n.freq)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.freq &gt; n.freq)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.time &lt; n.time)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.time &gt; n.time)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> time;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeSet&lt;Node&gt; tree;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;Integer, Node&gt; hash;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LFUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.time = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.tree = <span class=\"keyword\">new</span> TreeSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Node cur = hash.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        tree.remove(cur);</span><br><span class=\"line\">        cur.freq++;</span><br><span class=\"line\">        cur.time = ++time;</span><br><span class=\"line\">        tree.add(cur);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.get(key) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            hash.get(key).value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tree.size() == capacity) &#123; <span class=\"comment\">//若已达容量删除TreeSet中首个元素</span></span><br><span class=\"line\">            Node drop = (Node) tree.pollFirst();</span><br><span class=\"line\">            hash.remove(drop.key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Node cur = <span class=\"keyword\">new</span> Node(key, value, ++time);</span><br><span class=\"line\">        tree.add(cur);</span><br><span class=\"line\">        hash.put(key, cur);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>","tags":["算法"]},{"title":"Leetcode 3-无重复字符的最长子串","url":"/2020/03/18/Leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","content":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>面试栽在了这道题上，当时糊涂了没想明白，决定重做一遍。</p>\n<p>采用双指针，$i$ 和 $j$ 分别指向当前判断的子串的首尾。用<code>map&lt;char,int&gt;</code>保存字符上一次出现的位置+1，+1的原因是为了避免和map中当key不存在时，int默认值为0的情况冲突。同时维护遍历过程中的最大长度。</p>\n<p>初始化 $i=0, j=1$，每次判断 $s[j]$ 在map中的值，会存在三种情况：</p>\n<ol>\n<li><p>$m[s[j]] = 0$：</p>\n<p>表示 $s[j]$ 尚未在 $s[0, j)$ 中出现过。</p>\n</li>\n<li><p>$m[s[j]] - 1 &lt; i$：</p>\n<p>表示 $s[j]$ 在 $s[0, i)$ 中出现过，但没有在 $s[i,j)$ 中出现过。</p>\n</li>\n<li><p>$m[s[j]] - 1 \\ge i$：</p>\n<p>表示 $s[j]$ 在 $s[i,j)$ 中出现过。</p>\n</li>\n</ol>\n<p>在第1、2种情况中， $s[j]$ 并没有出现在当前判断的子串内，因此可以被加入到子串中，同时判断最大长度是否可更新。</p>\n<p>在第3种情况中，$s[j]$ 出现在了当前判断的子串内，设其位置为 $j’$ ，此时可直接使指针 $i=j’+1$，即令 $i=m[s[j]]$。因为当 $i$ 取 $[i, j’]$ 中任何值时，$s[i,j]$ 中都将存在重复字符。</p>\n<p>无论上述哪一种情况，在判断完 $s[j]$ 后，都应更新使 $m[s[j]]=j+1$ ，同时使 $j$ 右移一位。循环上述过程直到 $j$ 遍历完 $s$ ，此时维护的最大长度即为答案，算法复杂度 $O(n)$。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> str)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = <span class=\"number\">0</span>, e;</span><br><span class=\"line\">        <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; pos;<span class=\"comment\">//pos[ch]表示ch在str中出现的位置+1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        pos[str[s]] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (e = <span class=\"number\">1</span>; e &lt; str.length(); e++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos[str[e]] - <span class=\"number\">1</span> &gt;= s) </span><br><span class=\"line\">                s = pos[str[e]];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                ans = max(e-s+<span class=\"number\">1</span>, ans);</span><br><span class=\"line\">            pos[str[e]] = e + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","tags":["算法"]},{"title":"Leetcode 406-根据身高重建队列","url":"/2021/02/06/Leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/","content":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>\n<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>\n<p><strong>示例1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class=\"line\">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class=\"line\">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class=\"line\">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class=\"line\">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class=\"line\">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>\n<p><strong>示例2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class=\"line\">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>首先我们需要对完全无序的队列做一些预处理。考虑这样一个排队问题：</p>\n<p>有 $n$ 个人，将他们从高到矮排成一队，设排队每个位置上的身高分别是 $h_0,h1,\\cdots ,h_{n-1}$ 。</p>\n<p>若 $n$ 个人的身高不同，该问题十分简单。但若存在身高相同的人时，我们需要指定一个特殊的排序方式才能排出一个完整的队列。我们可以利用原问题提供的 $k$ 值。设 $h_i=h_j, k_i&gt;k_j$ 。显然，原问题中，身高相同时，$k$ 值越大的人所在位置越靠后，即 $h_i$ 必然会排在 $h_j$ 之后。因此可以设 $h_i = h_j - \\delta$ ，其中 $\\delta$ 是一个不影响其他身高排序的微小量。这样一来，每个人的身高又可以视为不同的了。</p>\n<p>解决这一问题只需要对原序列做这样一个排序：<strong>首先按第一分量（身高）降序排列，当第一分量相等时，按第二分量（k）升序排列</strong>。</p>\n<p>在完成这一排序后，我们再考虑原问题。原问题要求，对于队伍中位置 $i$ 的人，队伍之前身高 $\\ge h_i$ 的人数正好为 $k_i$。我们将上一问题排好的顺序重新排入下一个队列。当排入第 $i$ 个人时：</p>\n<ul>\n<li>第 $0, \\cdots , i-1$ 个人已经在队伍中安排好了位置。他们都比第 $i$ 个人高，因此，只要他们排在第 $i$ 个人前面即可对 $k_i$ 产生影响。</li>\n<li>第 $i+1, \\cdots, n-1$ 个人都比第 $i$ 个人矮，无论他们站在哪里都不会对第 $i$ 个人产生影响。</li>\n</ul>\n<p>因此，我们只要将第 $i$ 个人“插入”当前以排好的队伍，使得其前面正好有 $k_i$ 个人即可。依次处理每一个人，即可得到原问题需要的排序。</p>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] reconstructQueue(<span class=\"keyword\">int</span>[][] people) &#123;</span><br><span class=\"line\">        Arrays.sort(people, (o1, o2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o1[<span class=\"number\">0</span>] == o2[<span class=\"number\">0</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1[<span class=\"number\">1</span>] - o2[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o2[<span class=\"number\">0</span>] - o1[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;<span class=\"keyword\">int</span>[]&gt; ans = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] person : people) &#123;</span><br><span class=\"line\">            ans.add(person[<span class=\"number\">1</span>], person);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans.toArray(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[ans.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["算法"]},{"title":"Leetcode 60-第k个排列","url":"/2020/09/10/Leetcode-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/","content":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p>\n<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>\n<ol>\n<li>“123”</li>\n<li>“132”</li>\n<li>“213”</li>\n<li>“231”</li>\n<li>“312”</li>\n<li>“321”</li>\n</ol>\n<p>给定 n 和 k，返回第 k 个排列。</p>\n<p><strong>示例1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n &#x3D; 3, k &#x3D; 3</span><br><span class=\"line\">输出: &quot;213&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>示例2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n &#x3D; 4, k &#x3D; 9</span><br><span class=\"line\">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li><p><strong>全排列算法（笨笨）</strong></p>\n<p>给定一个排列a，题中生成下一个排列b的方法实际上是寻找一个使得a增加值最小的排列，该排列即为排列b。</p>\n<p>其算法描述如下：</p>\n<ol>\n<li>从右到左扫描当前排列，寻找第一个相邻递减数字。递减的数字称为<strong>Partition Number</strong>。</li>\n<li>从右到左扫描当前排列，寻找第一个比<strong>Partition Number</strong>大的数字。称其为<strong>Change Number</strong>。</li>\n<li>交换<strong>Partition Number</strong>和<strong>Change Number</strong>。</li>\n<li>逆向<strong>Partition Number</strong>所在位置右边的所有数字。</li>\n</ol>\n<p>完成以上四步操作即可得到使得排列a增加值最少的排列b。</p>\n<p>根据题中的描述，只需要对排列 <code>12...n</code> 执行 k-1 次该算法即可得到答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">nextPermutation</span><span class=\"params\">(String v)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(v);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从右到左扫描第一个相邻递减数字，即Partition Number</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = v.length(), pn = len;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v.charAt(i) &lt; v.charAt(i + <span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                pn = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pn == len) <span class=\"comment\">// 到达最后一个排列返回自身</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从右到左寻找第一个比Partition Number大的数字，称之为Change Number</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> cn = len;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt; pn; i--)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v.charAt(i) &gt; v.charAt(pn)) &#123;</span><br><span class=\"line\">                cn = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 交换PN和CN</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> tmp = sb.charAt(pn);</span><br><span class=\"line\">        sb.setCharAt(pn, sb.charAt(cn));</span><br><span class=\"line\">        sb.setCharAt(cn, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 逆向PN右侧的数，得到结果</span></span><br><span class=\"line\">        String s = sb.substring(pn + <span class=\"number\">1</span>);</span><br><span class=\"line\">        sb.delete(pn + <span class=\"number\">1</span>, len);</span><br><span class=\"line\">        </span><br><span class=\"line\">        StringBuilder sb2 = <span class=\"keyword\">new</span> StringBuilder(s);</span><br><span class=\"line\">        sb.append(sb2.reverse().toString());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">            sb.append(i);</span><br><span class=\"line\">        </span><br><span class=\"line\">        String ans = sb.toString();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; k; i++)</span><br><span class=\"line\">            ans = nextPermutation(ans);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","tags":["算法"]},{"title":"Leetcode 77-组合","url":"/2020/03/16/Leetcode-77-%E7%BB%84%E5%90%88/","content":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给定两个整数 $n$ 和 $k$，返回 $1\\cdots n$ 中所有可能的 $k$ 个数的组合。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,4],</span><br><span class=\"line\">  [3,4],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [1,4],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li><p><strong>DFS + 回溯</strong></p>\n<p>搜索起点为 $1\\cdots n - k + 1$，控制搜索树最大深度为 $k$，树中值为 $i$ 的子节点为 $[i+1, n]$。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; &amp;ans, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;v, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> cur)</span> </span>&#123;</span><br><span class=\"line\">        v.push_back(cur);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.size() == k) &#123;</span><br><span class=\"line\">            ans.push_back(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = cur + <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">                dfs(ans, v, n, k, i);</span><br><span class=\"line\">                v.pop_back();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; combine(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ans;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; cbs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span> || k &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i + k - <span class=\"number\">1</span> &lt;= n; i++) &#123;</span><br><span class=\"line\">            dfs(ans, cbs, n, k, i);</span><br><span class=\"line\">            cbs.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>利用公式</strong> $C_n^k=C_{n-1}^k+C_{n-1}^{k-1}$</p>\n<p>从 $1\\cdots n$ 中选 $k$ 个数只包含两种情况：</p>\n<ol>\n<li>这 $k$ 个数中包含 $n$ ，还需从剩下 $n-1$ 个数中选出 $k-1$ 个，方案数为 $C_{n-1}^{k-1}$ 。</li>\n<li>这 $k$ 个数中不包含 $n$ ，还需从剩下 $n-1$ 个数中选出 $k$ 个，方案数为 $C_{n-1}^k$。</li>\n</ol>\n<p>因此可递归求解，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; combine(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; ans;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">0</span> || k &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; cbs;</span><br><span class=\"line\">                cbs.push_back(i);</span><br><span class=\"line\">                ans.push_back(cbs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == n) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; cbs;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">                cbs.push_back(i);</span><br><span class=\"line\">            ans.push_back(cbs);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = combine(n - <span class=\"number\">1</span>, k);</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; tmp = combine(n - <span class=\"number\">1</span>, k - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class=\"line\">            tmp[i].push_back(n);</span><br><span class=\"line\">            ans.push_back(tmp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","tags":["算法"]},{"title":"Leetcode 面试题17.16-按摩师","url":"/2020/03/24/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817-16-%E6%8C%89%E6%91%A9%E5%B8%88/","content":"<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： [1,2,3,1]</span><br><span class=\"line\">输出： 4</span><br><span class=\"line\">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： [2,7,9,3,1]</span><br><span class=\"line\">输出： 12</span><br><span class=\"line\">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： [2,1,4,5,3,1,1,3]</span><br><span class=\"line\">输出： 12</span><br><span class=\"line\">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>定义 $dp[i]$ 表示以 $i$ 号预约结尾时的最大服务时长。</p>\n<p>首先注意到一定存在 $dp[i] \\ge dp[i-2]$ ，因为若 $dp[i]$ 中选择 $i-2$ 号预约时，将有 $dp[i]=dp[i-2]+nums[i]$ 。</p>\n<p>此外，当选择了 $i$ 号预约后，$i-1$ 号预约将无法被选择，根据上面结论，$dp[i-2] \\ge dp[i-4]$， $dp[i-3] \\ge dp[i-5]$，因此状态转移方程为：</p>\n<script type=\"math/tex; mode=display\">\ndp[i]=max(dp[i-2]+dp[i-3])+nums[i]</script><p>注意边界条件，$dp[0]=0$，$dp[i] = nums[i]\\space(i \\le 2)$。</p>\n<p>最终的答案为 $max(dp[n], dp[n-1])$ ，其中 $n$ 为序列长度。因为整个序列的最大服务时长序列中要么包括 $n$ 号预约，要么不包括。</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">massage</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">                dp[i] = nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == <span class=\"number\">2</span>)</span><br><span class=\"line\">                dp[i] = dp[i - <span class=\"number\">2</span>] + nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                dp[i] = max(dp[i - <span class=\"number\">2</span>], dp[i - <span class=\"number\">3</span>]) + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(dp[n - <span class=\"number\">1</span>], dp[n - <span class=\"number\">2</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>此处时间复杂度和空间复杂度均为 $O(n)$ ，由于我们只需要 $dp[n]$ 和 $dp[n-1]$ ，且每个状态的计算最多只涉及到前3项，因此可以用变量代替数组，空间复杂度降低为 $O(1)$ 。</p>\n","tags":["算法"]},{"title":"Missing CSE Homework","url":"/2021/03/15/Missing-CSE-Homework/","content":"<p><a href=\"https://missing.csail.mit.edu/\">Missing CSE</a>是MIT开设的一门的小学期课程，讲述了许多目前CS高等教育中严重缺失但却在工业界广泛应用或能极大提升生产力的工具与知识。</p>\n<p>本文记录了部分Homework的解答。</p>\n<a id=\"more\"></a>\n<h2 id=\"Course-overview-the-shell\"><a href=\"#Course-overview-the-shell\" class=\"headerlink\" title=\"Course overview + the shell\"></a>Course overview + the shell</h2><p>创建一个名为 <code>missing</code> 的文件夹，并在其中创建一个名为 <code>semester</code> 的文件并写入：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure><br>使用 <code>chmod</code> 为 <code>semester</code> 添加执行权限。</p>\n<p>写一段命令将 <code>semester</code> 文件输出的最后更改日期信息到 <code>last-modified.txt</code> 中。<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Answer</span></span><br><span class=\"line\">./semester | grep <span class=\"string\">&#x27;last-modified&#x27;</span> &gt; <span class=\"string\">&#x27;last-modified.txt&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Shell-Tools-and-Scripting\"><a href=\"#Shell-Tools-and-Scripting\" class=\"headerlink\" title=\"Shell Tools and Scripting\"></a>Shell Tools and Scripting</h2><ul>\n<li><p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code> 命令，（重新）加载函数。<br><strong>解答：</strong><br><em>macro.sh</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">macro</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">export</span> MACRO_DIR=$(<span class=\"built_in\">pwd</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">polo</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cd</span> <span class=\"variable\">$MACRO_DIR</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行过程</p>\n<center><img src=\"/2021/03/15/Missing-CSE-Homework/1.png\" width=\"45%\"></center>\n</li>\n<li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\">  </span><br><span class=\"line\">n=$(( RANDOM % <span class=\"number\">100</span> ))</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ n -eq 42 ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">   <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Something went wrong&quot;</span></span><br><span class=\"line\">   &gt;&amp;2 <span class=\"built_in\">echo</span> <span class=\"string\">&quot;The error was using magic numbers&quot;</span></span><br><span class=\"line\">   <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>解答：</strong><br>将上述内容写入 <code>script.sh</code>，创建 <code>test.sh</code> ，写入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">status=0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> [[ <span class=\"variable\">$status</span> -eq 0 ]]; <span class=\"keyword\">do</span></span><br><span class=\"line\">    ./script.sh &gt;&gt; out 2&gt;&gt; err</span><br><span class=\"line\">    status=$?</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"subst\">$(wc -l out)</span> before error.&quot;</span></span><br></pre></td></tr></table></figure>\n<p>运行过程</p>\n<center><img src=\"/2021/03/15/Missing-CSE-Homework/2.png\" width=\"70%\"></center>\n</li>\n<li><p>编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code> 的参数 <code>-d</code> ）<br><strong>解答：</strong><br>懒得找有HTML的文件夹，就用 <code>.sh</code> 文件代替了。创建文件 <code>zipsh</code> ，写入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">find <span class=\"variable\">$1</span> -name <span class=\"string\">&#x27;*.sh&#x27;</span> -print0 | xargs -0 zip -r sh.zip</span><br></pre></td></tr></table></figure>\n<p>运行过程</p>\n<center><img src=\"/2021/03/15/Missing-CSE-Homework/3.png\" width=\"70%\"></center>\n\n</li>\n</ul>\n<h2 id=\"Editors-Vim\"><a href=\"#Editors-Vim\" class=\"headerlink\" title=\"Editors (Vim)\"></a>Editors (Vim)</h2><p>这节讲了Vim的一些基本操作，学习一下可以极大提升命令行环境下的工作效率。各种快捷键就不在此赘述（vimtutor是个好东西）。</p>\n<p>这里记录一下一个Demo的修改过程。如下是一个有问题的fizz buzz实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># fizz.py</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fizz_buzz</span>(<span class=\"params\">limit</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(limit):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">3</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;fizz&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">5</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;fizz&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">3</span> <span class=\"keyword\">and</span> i % <span class=\"number\">5</span>:</span><br><span class=\"line\">            print(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    fizz_buzz(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>main</code> 方法没有调用<br><code>vim fizz.py</code><br>输入 <code>G</code> 到底文件尾<br>输入 <code>o</code> 向后新增一行<br>输入 <code>main</code> 方法调用代码<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure></li>\n<li><code>fizz_buzz</code> 方法中的循环从0开始<br>输入 <code>3G</code> 跳到第3行<br>输入 <code>%</code> 跳到 <code>(limit)</code> 尾<br>输入 <code>b</code> 向前跳1个词<br>输入 <code>i</code> ，将代码变为<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, limit+<span class=\"number\">1</span>):</span><br></pre></td></tr></table></figure></li>\n<li>5的倍数打印的是”fizz”<br>输入 <code>7G</code> 跳到第7行<br>输入 <code>ci&#39;</code> 清除”fizz”<br>输入”buzz”</li>\n<li>15的倍数打印的”fizz”和”buzz”在两行<br>输入 <code>5G</code> 跳到第5行<br>输入 <code>$</code> 跳到行尾<br>输入 <code>i</code> ，将代码变为<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">print(<span class=\"string\">&#x27;fizz&#x27;</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>\n输入 <code>7G</code> 跳到第7行<br>输入 <code>$</code> 跳到行尾<br>输入 <code>.</code> 重复第五行的编辑</li>\n<li><code>main</code> 方法中的10是硬编码<br>输入 <code>2G</code> 跳到第2行<br>输入 <code>O</code> 在前新增一行，添加<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n输入 <code>14G</code> 跳到第14行<br>输入 <code>%</code> 跳到 <code>(10)</code> 尾<br>输入 <code>ci(</code> 清除并编辑括号内内容，改为<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">fizz_buzz(<span class=\"built_in\">int</span>(sys.argv[<span class=\"number\">1</span>]))</span><br></pre></td></tr></table></figure>\n修改后的文件内容为<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># fizz.py</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fizz_buzz</span>(<span class=\"params\">limit</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, limit+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">3</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;fizz&#x27;</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">5</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;buzz&#x27;</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">3</span> <span class=\"keyword\">and</span> i % <span class=\"number\">5</span>:</span><br><span class=\"line\">            print(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span>():</span></span><br><span class=\"line\">    fizz_buzz(<span class=\"built_in\">int</span>(sys.argv[<span class=\"number\">1</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Data-Wrangling\"><a href=\"#Data-Wrangling\" class=\"headerlink\" title=\"Data Wrangling\"></a>Data Wrangling</h2><p>这节介绍了“Data Wrangling”。所谓“Data Wrangling”，描述的是通过一系列操作从原始数据中过滤得到我们需要的数据。在类Unix系统上，这通常可以通过一系列命令和管道来完成。</p>\n<ul>\n<li><p>完成 <a href=\"https://regexone.com/\">short interactive regex tutorial</a><br>这是一个循序渐进的Regex教程，这里记录一下答案</p>\n<ol>\n<li>匹配三个字符串 <code>abcdefg</code> / <code>abcde</code> / <code>abc</code><br><strong><code>abc[d-g]*</code></strong></li>\n<li>匹配 <code>abc123xyz</code> / <code>define &quot;123&quot;</code> / <code>var g = 123;</code> 中的所有数字<br><strong><code>\\d+</code>，或者暴力的 <code>123</code></strong></li>\n<li>匹配 <code>cat.</code> / <code>896.</code> / <code>?=+.</code> 但不匹配 <code>abc1</code><br><strong><code>.&#123;3&#125;\\.</code>，或 <code>...\\.</code></strong></li>\n<li>匹配 <code>can</code> / <code>man</code> / <code>fan</code> 但不匹配 <code>dan</code> / <code>ran</code> / <code>pan</code><br><strong><code>[cmf]an</code>，或者 <code>[^drp]an</code></strong></li>\n<li>匹配 <code>hog</code> / <code>dog</code> 但不匹配 <code>bog</code><br><strong><code>[hd]og</code>，或者 <code>[^b]og</code></strong></li>\n<li>匹配 <code>Ana</code> / <code>Bob</code> / <code>Cpc</code> 但不匹配 <code>aax</code> / <code>bby</code> / <code>ccz</code><br><strong><code>[A-C][n-p][a-c]</code></strong></li>\n<li>匹配 <code>wazzzzzup</code> / <code>wazzzup</code> 但不匹配 <code>wazup</code><br><strong><code>waz&#123;2,&#125;up</code></strong></li>\n<li>匹配 <code>aaaabcc</code> / <code>aabbbbc</code> / <code>aacc</code> 但不匹配 <code>a</code><br><strong><code>a+b*c+</code></strong></li>\n<li>匹配 <code>1 file found?</code> / <code>2 files found?</code> / <code>24 files found?</code> 但不匹配 <code>No files found.</code><br><strong><code>\\d+ files? found\\?</code></strong></li>\n<li>匹配 <code>1.⊔⊔⊔abc</code> / <code>2.⊔(tab)abc</code> / <code>3.⊔⊔⊔⊔⊔⊔⊔⊔⊔⊔⊔abc</code> 但不匹配 <code>4.abc</code><br><strong><code>\\d\\.\\s+abc</code></strong></li>\n<li>匹配 <code>Mission: successful</code> 但不匹配 <code>Last Mission: unsuccessful</code> / <code>Next Mission: successful upon capture of target</code><br><strong><code>^Mission: successful$</code></strong></li>\n<li>捕获 <code>file_record_transcript.pdf</code> / <code>file_07241999.pdf</code> 中的文件名，但不匹配 <code>testfile_fake.pdf.tmp</code><br><strong><code>^(file.+)\\.pdf$</code></strong></li>\n<li>捕获 <code>Jan 1987</code> / <code>May 1969</code> / <code>Aug 2011</code> 中的整个日期和年份（两个捕获组）<br><strong><code>(\\w+ (\\d+))</code></strong></li>\n<li>捕获 <code>1280x720</code> / <code>1920x1600</code> / <code>1024x768</code> 等分辨率中的宽和高<br><strong><code>(\\d+)x(\\d+)</code></strong></li>\n<li>匹配 <code>I love cats</code> / <code>I love dogs</code> 但不匹配 <code>I love logs</code> / <code>I love cogs</code><br><strong><code>I love (cat|dog)s</code></strong></li>\n<li>\b\b\b\b\b匹配 <code>The quick brown fox jumps over the lazy dog.</code> / <code>There were 614 instances of students getting 90.0% or above.</code> / <code>The FCC had to censor the network for saying &amp;$#*@!.</code><br><strong>偷懒的<code>.*</code>，或<code>^The(re)? (.+( |\\.))+$</code></strong></li>\n<li>匹配 <code>3.14529</code> / <code>-255.34</code> / <code>128</code> / <code>1.9e10</code> / <code>123,340.00</code> 但不匹配 <code>720p</code><br><strong><code>^\\-?(\\d,?)+\\.?\\d+(e\\d+)?$</code> 或 <code>^\\-?\\d+(,\\d+)*(\\.\\d+(e\\d+)?)?$</code></strong></li>\n<li>捕获 <code>415-555-1234</code> / <code>650-555-2345</code> / <code>(416)555-3456</code> / <code>202 555 4567</code> / <code>4035555678</code> / <code>1 416 555 9292</code> 的区号，即 <code>415</code> / <code>650</code> / <code>416</code> / <code>202</code> / <code>403</code> / <code>416</code><br><strong><code>1?(\\s|-)?\\(?(\\d&#123;3&#125;)\\)?(\\s|-)?\\d&#123;3&#125;(\\s|-)?\\d&#123;4&#125;</code></strong></li>\n<li>捕获 <code>tom@hogwarts.com</code> / <code>tom.riddle@hogwarts.com</code> / <code>tom.riddle+regexone@hogwarts.com</code> / <code>tom@hogwarts.eu.com</code> / <code>potter@hogwarts.com</code> / <code>harry@hogwarts.com</code> / <code>hermione+regexone@hogwarts.com</code> 中的用户名<br><strong><code>^(\\w+(\\.\\w+)*)(\\+\\w+)*@\\w+(\\.\\w+)+$</code></strong></li>\n<li>捕获 <code>&lt;a&gt;This is a link&lt;/a&gt;</code> / <code>&lt;a href=&#39;https://regexone.com&#39;&gt;Link&lt;/a&gt;</code> / <code>&lt;div class=&#39;test_style&#39;&gt;Test&lt;/div&gt;</code> / <code>&lt;div&gt;Hello &lt;span&gt;world&lt;/span&gt;&lt;/div&gt;</code> 中的HTML标签<br><strong><code>&lt;(\\w+)( \\w+=\\&#39;.+\\&#39;)*&gt;.*&lt;/(\\w+)&gt;</code></strong></li>\n<li>捕获下列文件中图片文件的文件名和扩展名，且不匹配其他文件名：<br><code>.bash_profile</code> / <code>workspace.doc</code> / <code>img0912.jpg</code> / <code>updated_img0912.png</code> / <code>documentation.html</code> / <code>favicon.gif</code> / <code>img0912.jpg.tmp</code> / <code>access.lock</code><br><strong><code>^(\\w+)\\.((jpg)|(png)|(gif))$</code></strong></li>\n<li>去掉字符串头尾的空白符，捕获文本内容：<code>⊔(tab)⊔(tab)⊔(tab)The quick brown fox...</code> / <code>⊔⊔jumps over the lazy dog.</code><br><strong><code>^\\s*(.*)\\s*$</code></strong></li>\n<li>捕获下列日志中的文件名、方法名、行号：<br><code>E/( 1553):   at widget.List.makeView(ListView.java:1727)</code><br><code>E/( 1553):   at widget.List.fillDown(ListView.java:652)</code><br><code>E/( 1553):   at widget.List.fillFrom(ListView.java:709)</code><br>跳过：<br><code>W/dalvikvm( 1553): threadid=1: uncaught exception</code><br><code>E/( 1553): FATAL EXCEPTION: main</code><br><code>E/( 1553): java.lang.StringIndexOutOfBoundsException</code><br><strong><code>[A-Z]/\\( \\d+\\):   at \\w+\\.\\w+\\.(\\w+)\\((\\w+\\.\\w+):(\\d+)\\)</code></strong></li>\n<li>捕获下列URL中的协议名、主机、端口：<br><code>ftp://file_server.com:21/top_secret/life_changing_plans.pdf</code><br><code>https://regexone.com/lesson/introduction#section</code><br><code>file://localhost:4040/zip_file</code><br><code>https://s3cur3-server.com:9999/</code><br><code>market://search/angry%20birds</code><br><strong><code>^(\\w+)://([\\w\\-\\.]+)(:(\\d+))?</code></strong></li>\n</ol>\n</li>\n<li><p>从 <code>/usr/share/dict/words</code> 找出包含至少3个<code>a</code>，且不以<code>s</code>结尾的单词：</p>\n<ol>\n<li>出现次数排名前三的最后两位字母的组合是？这些两位字母组合的个数？<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat /usr/share/dict/words | grep -E <span class=\"string\">&#x27;^(.*a.*)&#123;3&#125;.*[^s]$&#x27;</span> | sed -E <span class=\"string\">&#x27;s/.*(..)$/\\1/&#x27;</span> | sort | uniq -c | sort -r</span><br><span class=\"line\">| head -n3</span><br></pre></td></tr></table></figure>\n<code>cat /usr/share/dict/words</code> 打印出文件中的所有单词<br><code>grep -E &#39;^(.*a.*)&#123;3&#125;.*[^s]$&#39;</code> 匹配出其中包含至少3个<code>a</code>，且不以<code>s</code>结尾的单词<br><code>sed -E &#39;s/.*(..)$/\\1/&#39;</code> 使用正则替换，提取出这些单词的最后两位字母<br><code>sort | uniq -c</code> 将字母组合排序，合并重复项且计数<br><code>sort -r | head -n3</code> 以出现次数为key逆序排序，并提取出现次数前三名的组合</li>\n<li>哪些两位字母组合没有出现？<br><a href=\"https://www.reddit.com/r/commandline/comments/i2tnf4/problem_find_twoletter_combinations_that_do_not/\">学习自这里</a><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">comm -13</span><br><span class=\"line\">&lt;(cat /usr/share/dict/words | grep -E <span class=\"string\">&#x27;^(.*a.*)&#123;3&#125;.*[^s]$&#x27;</span> | sed -E <span class=\"string\">&#x27;s/.*(..)$/\\1/&#x27;</span> | sort -u) </span><br><span class=\"line\">&lt;(<span class=\"built_in\">echo</span> &#123;a..z&#125;&#123;a..z&#125; | tr <span class=\"string\">&quot; &quot;</span> <span class=\"string\">&quot;\\n&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>使用 <code>sed</code> 进行原地替换是一个很有诱惑力的选择，如 <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code> 。但这条命令是无法实现目标的，为什么？是否仅对 <code>sed</code> 命令有此限制？查询 <code>sed</code> 的文档，找到原地替换的方法。<br><a href=\"https://stackoverflow.com/questions/5171901/find-and-replace-in-file-and-overwrite-file-doesnt-work-it-empties-the-file\">学习自这里</a></p>\n<blockquote>\n<p>When the shell sees &gt; index.html in the command line it opens the file index.html for writing, wiping off all its previous contents.</p>\n</blockquote>\n<p>简言之，在 <code>sed</code> 真正执行前，重定向已经将文件内容清空了。因此这一问题不仅仅只针对 <code>sed</code> ，其他命令同样无法通过这一操作进行原地修改。</p>\n<p><code>sed</code> 的 <code>-i</code> 选项提供了原地替换，上面的语句应写为：<br><code>sed -i &#39;.tmp&#39; s/REGEX/SUBSTITUTION/ input.txt</code><br>这一语句在执行原地替换前会先生成一个后缀为 <code>.tmp</code> 的备份文件。如果使用 <code>-i &#39;&#39;</code> ，则不会生成任何中间文件。</p>\n</li>\n</ul>\n<h2 id=\"Command-line-Environment\"><a href=\"#Command-line-Environment\" class=\"headerlink\" title=\"Command-line Environment\"></a>Command-line Environment</h2><h3 id=\"Job-Control\"><a href=\"#Job-Control\" class=\"headerlink\" title=\"Job Control\"></a>Job Control</h3><ol>\n<li>我们可以通过 <code>ps aux | grep</code> 来获得我们启动的job的pid，并kill它们。事实上还有更方便<br>的做法。后台启动一个 <code>sleep 10000</code> 的job：使用 <code>pgrep</code> 查找pid。使用 <code>pkill</code> 来结束进程，从而使得无需自行填入pid。（提示：使用 <code>-af</code>）<br><strong>A：</strong><br>查找pid：<code>pgrep -af &#39;sleep 10000&#39;</code><br>kill进程：<code>pkill -af &#39;sleep 10000&#39;</code></li>\n<li>写一个 <code>pidwait</code> 函数，接收一个pid，并等到该进程结束，并执行 <code>ls</code> （提示：<code>kill -0</code> 不会向指定进程发送信号，但会根据进程是否存在返回成功（0）或失败（非0））<br><strong>A：</strong><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/zsh</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pidwait</span></span> () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> <span class=\"built_in\">kill</span> -0 <span class=\"variable\">$1</span> 2&gt;/dev/null</span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">  <span class=\"keyword\">done</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;process <span class=\"variable\">$1</span> has finished.&quot;</span></span><br><span class=\"line\">  ls</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Terminal-Multiplexer\"><a href=\"#Terminal-Multiplexer\" class=\"headerlink\" title=\"Terminal Multiplexer\"></a>Terminal Multiplexer</h3><p><a href=\"https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/\"><code>tmux</code> tutorial</a></p>\n<p><a href=\"https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/\">自定义 <code>tmux</code></a> ：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ~/.tmux.conf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#remap prefix from &#x27;C-b&#x27; to &#x27;C-a&#x27;</span></span><br><span class=\"line\">unbind C-b</span><br><span class=\"line\">set-option -g prefix C-a</span><br><span class=\"line\">bind-key C-a send-prefix</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable mouse control (clickable windows, panes, resizable panes)</span></span><br><span class=\"line\"><span class=\"comment\"># set -g mouse-select-window on</span></span><br><span class=\"line\"><span class=\"comment\"># set -g mouse-select-pane on</span></span><br><span class=\"line\"><span class=\"comment\"># set -g mouse-resize-pane on</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enable mouse mode (tmux 2.1 and above)</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -g mouse on</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Aliases\"><a href=\"#Aliases\" class=\"headerlink\" title=\"Aliases\"></a>Aliases</h3><p>使用 <code>history | awk &#39;&#123;$1=&quot;&quot;;print substr($0,2)&#125;&#39; | sort | uniq -c | sort -n | tail -n 10</code> 可以从history中读取最常使用的10条命令，为它们设置别名</p>\n<p><strong>A：</strong></p>\n<p>我的Top 10 cmd list如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 30 l</span><br><span class=\"line\"> 35 ssh cbs@192.168.1.149</span><br><span class=\"line\"> 39 git pull</span><br><span class=\"line\"> 44 hexo g -d</span><br><span class=\"line\"> 59 npm start</span><br><span class=\"line\"> 71 <span class=\"built_in\">cd</span> ~</span><br><span class=\"line\"> 75 hexo s</span><br><span class=\"line\"> 82 ls -a</span><br><span class=\"line\">170 <span class=\"built_in\">cd</span> ..</span><br><span class=\"line\">849 ls</span><br></pre></td></tr></table></figure>\n<p>没想到 hexo 的使用频率还挺高，于是做了以下别名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ~/.zprofile</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># setting hexo aliases</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> hs=<span class=\"string\">&quot;hexo s&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> hgd=<span class=\"string\">&quot;hexo g -d&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Remote-Machines\"><a href=\"#Remote-Machines\" class=\"headerlink\" title=\"Remote Machines\"></a>Remote Machines</h3><p>查询 <code>ssh</code> 的 <code>-N</code> 和 <code>-f</code> 标志，实现后台端口转发：</p>\n<p><strong>A：</strong></p>\n<p>首先在VM上启动一个HTTP服务，监听8090端口，利用 <code>-L</code> 进行端口转发，可以写出命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -L 8090:localhost:8090 VM</span><br></pre></td></tr></table></figure>\n<p>该命令监听本地的8090端口，并将其转发到VM的8090端口。然而该命令的问题在于，在实现端口转发的同时还登录了VM。如果我们不需要登录，就可以使用 <code>-N</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ssh manpage</span><br><span class=\"line\"></span><br><span class=\"line\">-N      Do not execute a remote command.  This is useful for just forwarding ports.</span><br></pre></td></tr></table></figure>\n<p>加上 <code>-N</code> 后，端口转发命令变成了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -N -L 8090:localhost:8090 VM</span><br></pre></td></tr></table></figure>\n<p>我们不会再登入VM了，然而，这条命令仍然存在阻塞问题。阻塞的命令导致我们无法在当前终端中继续其他工作。为了让其在后台工作，我们可以引入 <code>-f</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># ssh manpage</span><br><span class=\"line\"></span><br><span class=\"line\">-f      Requests ssh to go to background just before command execution.  </span><br><span class=\"line\">This is useful if ssh is going to ask for passwords or passphrases, but the</span><br><span class=\"line\">user wants it in the background.  This implies -n.  The recommended way to </span><br><span class=\"line\">start X11 programs at a remote site is with something like ssh -f host xterm.</span><br></pre></td></tr></table></figure>\n<p>最终，命令变成了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -fN -L 8090:localhost:8090 VM</span><br></pre></td></tr></table></figure>\n<p>实现了不登入VM，运行在后台的端口转发</p>\n"},{"title":"Scientifically Surfing the Internet","url":"/2020/03/13/Scientifically-Surfing-the-Internet/","content":"<p>一个不可告人的秘密</p>\n<a id=\"more\"></a>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li><p><strong>购买</strong></p>\n<p>Vultr选购VPS，OS选择<strong>Ubuntu 18.04</strong>，该版本已支持BBR，无需更新内核</p>\n<p>下方选择<strong>Enable IPv6</strong>，方便在某些时候IPv4被墙时利用IPv6转发</p>\n<p>SSH Keys中放上本机的公钥</p>\n<p>Hostname&amp;Label设置的是示例的名称</p>\n</li>\n<li><p><strong>测试</strong></p>\n<p>ping一下国内的地址，看本VPS的IP是否被墙，被墙了需要换</p>\n<p>在配置完成后也可以利用Win端SS客户端的日志来测试</p>\n</li>\n</ul>\n<h2 id=\"ShadowSocks安装\"><a href=\"#ShadowSocks安装\" class=\"headerlink\" title=\"ShadowSocks安装\"></a>ShadowSocks安装</h2><h4 id=\"更新apt\"><a href=\"#更新apt\" class=\"headerlink\" title=\"更新apt\"></a>更新apt</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装setuptools\"><a href=\"#安装setuptools\" class=\"headerlink\" title=\"安装setuptools\"></a>安装setuptools</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install setuptools</span><br></pre></td></tr></table></figure>\n<h4 id=\"从github安装SS\"><a href=\"#从github安装SS\" class=\"headerlink\" title=\"从github安装SS\"></a>从github安装SS</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure>\n<p>可以用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssserver --version</span><br></pre></td></tr></table></figure>\n<p>查看SS的版本号，当前显示的是3.0.0</p>\n<h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><p>创建Shadowsocks配置文件所在文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure>\n<p>在本机编辑好配置文件<strong>config.json</strong>，内容如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;server&quot;</span>:<span class=\"string\">&quot;45.77.181.212&quot;</span>,<span class=\"comment\">//当前主机IP</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;server_port&quot;</span>:<span class=\"number\">8388</span>,<span class=\"comment\">//端口</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;local_address&quot;</span>:<span class=\"string\">&quot;127.0.0.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;local_port&quot;</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span>:<span class=\"string\">&quot;password&quot;</span>,<span class=\"comment\">//密码</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timeout&quot;</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;method&quot;</span>:<span class=\"string\">&quot;aes-256-cfb&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;fast_open&quot;</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后将其放入 <strong>/etc/shadowsocks</strong> 目录下</p>\n<h2 id=\"测试Shadowsocks配置\"><a href=\"#测试Shadowsocks配置\" class=\"headerlink\" title=\"测试Shadowsocks配置\"></a>测试Shadowsocks配置</h2><h4 id=\"启用配置文件\"><a href=\"#启用配置文件\" class=\"headerlink\" title=\"启用配置文件\"></a>启用配置文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>之后在客户端填写<strong>服务器地址、密码、端口</strong>，就可以测试了。可以尝试打开Google，如果能正常打开则本次抽到的IP大概率没问题</p>\n<p>同时，在客户端开启全局模式的前提下，可以打开<strong><a href=\"http://ip138.com/\">http://ip138.com/</a></strong>，查看IP是否已变为了服务器的IP</p>\n<p>测试完成后Ctrl + C关闭SS</p>\n<h2 id=\"配置Systemd管理Shadowsocks\"><a href=\"#配置Systemd管理Shadowsocks\" class=\"headerlink\" title=\"配置Systemd管理Shadowsocks\"></a>配置Systemd管理Shadowsocks</h2><p>接下来需要配置SS的自启动，这里用到的是<strong>systemd</strong></p>\n<h4 id=\"新建Shadowsocks管理文件\"><a href=\"#新建Shadowsocks管理文件\" class=\"headerlink\" title=\"新建Shadowsocks管理文件\"></a>新建Shadowsocks管理文件</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>\n<p>在文件中复制粘贴以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description&#x3D;Shadowsocks Server</span><br><span class=\"line\">After&#x3D;network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br><span class=\"line\">Restart&#x3D;on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动Shadowsocks\"><a href=\"#启动Shadowsocks\" class=\"headerlink\" title=\"启动Shadowsocks\"></a>启动Shadowsocks</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure>\n<h4 id=\"设置开机启动\"><a href=\"#设置开机启动\" class=\"headerlink\" title=\"设置开机启动\"></a>设置开机启动</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>自此，配置完成</p>\n<h2 id=\"BBR\"><a href=\"#BBR\" class=\"headerlink\" title=\"BBR\"></a>BBR</h2><p>BBR是Google最新开发的TCP拥塞控制算法，可以提高带宽</p>\n<p>输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">lsmod | grep bbr</span><br></pre></td></tr></table></figure>\n<p>若结果中出现了<strong>tcp_bbr</strong>，则说明BBR已开启。Ubuntu 18.04版本已经默认开启了BBR，无需再升级内核版本</p>\n<h2 id=\"关于Google-Scholar被墙\"><a href=\"#关于Google-Scholar被墙\" class=\"headerlink\" title=\"关于Google Scholar被墙\"></a>关于Google Scholar被墙</h2><p>某些IPv4地址可能会被Google Scholar墙掉，这时候可以配置位于<strong>/etc</strong>目录下的<strong>hosts</strong>文件，利用IPv6地址转发</p>\n<p>添加内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Google Scholar Search</span><br><span class=\"line\">2404:6800:4004:81a::200e scholar.google.cn</span><br><span class=\"line\">2404:6800:4004:81a::200e scholar.google.com.hk</span><br><span class=\"line\">2404:6800:4004:81a::200e scholar.google.com</span><br><span class=\"line\">2404:6800:4004:81a::200e scholar.l.google.com</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>之后，利用以下命令保存并重启网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>"},{"title":"一次造轮子的尝试","url":"/2021/10/08/%E4%B8%80%E6%AC%A1%E9%80%A0%E8%BD%AE%E5%AD%90%E7%9A%84%E5%B0%9D%E8%AF%95/","content":"<p>断断续续三个月，终于把这个<a href=\"https://github.com/sunxia0/subspark\">玩具轮子</a>造了个大概，还是得写点东西总结一下。</p>\n<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对着<a href=\"http://sparkjava.com/\">Spark</a>依葫芦画瓢，于是有了<a href=\"https://github.com/sunxia0/subspark\">SubSpark</a>。SubSpark是啥？用一句简单的话概述就是一个<strong>Servlet-like Container</strong>。这里我用了Servlet-like这个词而不是Servlet，是因为我并没有实现完整的servlet-api，而是借鉴Spark定制了一套更轻量化的Route接口，能实现和Servlet类似的自定义处理HTTP请求的功能。更进一步，SubSpark实现的功能包括：</p>\n<ul>\n<li><p><strong>内置的HTTP Server</strong></p>\n</li>\n<li><p><strong>Server运行参数配置</strong></p>\n<p>IP、监听端口、运行线程数、静态资源根目录</p>\n</li>\n<li><p><strong>Route</strong></p>\n<p>类似servlet-api中的Servlet接口，自定义处理HTTP请求</p>\n</li>\n<li><p><strong>Filter</strong></p>\n<p>类似servlet-api中的Filter接口，过滤HTTP请求</p>\n</li>\n<li><p><strong>Request / Response</strong></p>\n<p>封装了HTTP细节的对象</p>\n</li>\n<li><p><strong>Session</strong></p>\n<p>实现简单的有状态请求机制</p>\n</li>\n</ul>\n<p>此外，相较于Tomcat / Jetty等Servlet Container，SubSpark会通过API更着重强调RESTful这一概念，这一点在<a href=\"https://github.com/sunxia0/subspark#route\">文档</a>中也有提及，为用户构建RESTful的微服务应用提供指导。</p>\n<h2 id=\"技术架构\"><a href=\"#技术架构\" class=\"headerlink\" title=\"技术架构\"></a>技术架构</h2><center><img src=\"/2021/10/08/%E4%B8%80%E6%AC%A1%E9%80%A0%E8%BD%AE%E5%AD%90%E7%9A%84%E5%B0%9D%E8%AF%95/subspark.png\" width=\"50%\"></center>\n\n<p>整个框架的架构如上图所示，工作流程还是比较清晰的。</p>\n<p><code>HttpListener</code> 负责启动 <code>ServerSocket</code> ，监听连接，并将获得的 <code>Socket</code> 交付 <code>HttpHandler</code> 。</p>\n<p><code>HttpHandler</code> 用 <code>HttpTask</code> 封装 <code>Socket</code> ，实现整个服务器业务逻辑。创建的 <code>HttpTask</code> 对象将交付 <code>HttpHandler</code> 中的线程池运行。</p>\n<p><code>HttpTask</code> 内部的 <code>Socket</code> 直接对接 <code>HttpParser</code>。它负责从 <code>SocketInputStream</code> 中读取字节流，构建 <code>Request</code> 对象，并将处理完毕的 <code>Response</code> 对象发送到 <code>SocketOutputStream</code> 。</p>\n<p><code>RequestHandler</code> 接收来自 <code>HttpParser</code> 构建的 <code>Request</code> 对象，解析HTTP请求，决定是调用 <code>Router</code> 进行动态处理还是调用 <code>StaticFilesHandler</code> 读取静态资源。</p>\n<p><code>Service</code> 组合了上述组件，向外提供统一的使用接口。</p>\n<p><code>SubSpark</code> 中用单例模式封装了 <code>Service</code> ，为用户提供接口。</p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><ul>\n<li><p>测试应用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.subspark.SubSpark.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        before(<span class=\"string\">&quot;/hello&quot;</span>, (req, res) -&gt; System.out.println(<span class=\"string\">&quot;In before /hello&quot;</span>));</span><br><span class=\"line\">        get(<span class=\"string\">&quot;/hello&quot;</span>, (req, res) -&gt; <span class=\"string\">&quot;Hello, World!\\n&quot;</span>);</span><br><span class=\"line\">        after(<span class=\"string\">&quot;/hello&quot;</span>, (req, res) -&gt; System.out.println(<span class=\"string\">&quot;In after /hello&quot;</span>));</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该应用为路径 <code>/hello</code> 分别设置一条before filter，一条route，一条after filter。此外，在测试目录下还建立了一个静态资源文件夹，包含一个内容如下的 <code>index.html</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Sample File<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>测试环境</p>\n<p><strong>CPU</strong>: Intel Xeon Silver 4214 @ 2.20GHz, 36 cores</p>\n<p><strong>Memory</strong>: 128G</p>\n<p><strong>Disk</strong>: 5.0T</p>\n</li>\n<li><p>测试方法</p>\n<p>使用<a href=\"http://httpd.apache.org/docs/2.0/programs/ab.html\">Apache Bench</a>，分别对调用route的路径 <code>/hello</code> 和获取 <code>index.html</code> 的路径 <code>/</code> 进行测试十、百、千级并发测试。为控制变量，每次测试重启测试环境。</p>\n</li>\n<li><p>测试参数</p>\n<ul>\n<li><p>Apache Bench设置</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ab -n [N] -t [T] -c [C] [<span class=\"built_in\">test</span> URL]</span><br></pre></td></tr></table></figure>\n<p>  <code>-n</code> 用于设置模拟请求的总次数为 <code>N</code> </p>\n<p>  <code>-t</code> 用于设置每个模拟请求的最长停留时间为 <code>T</code> 秒；使用 <code>-t</code> 隐含携带参数 <code>-n 50000</code></p>\n<p>  <code>-c</code> 用于设置模拟请求的并发数为 <code>C</code></p>\n<p>  通常 <code>-n</code> 和 <code>-t</code> 分开使用，分别和 <code>-c</code> 进行组合：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模拟1个用户请求1000次</span></span><br><span class=\"line\">ab -n 1000 [<span class=\"built_in\">test</span> URL]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模拟500个用户共请求1000次（每个用户2次）</span></span><br><span class=\"line\">ab -n 1000 -c 500 [<span class=\"built_in\">test</span> URL]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模拟500个用户共请求50000次，每个请求最长等待10s</span></span><br><span class=\"line\">ab -t 10 -c 500 [<span class=\"built_in\">test</span> URL]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试设置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># route测试</span></span><br><span class=\"line\">ab -n 30 -c 10 <span class=\"string\">&#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\">ab -n 300 -c 100 <span class=\"string\">&#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\">ab -n 3000 -c 1000 <span class=\"string\">&#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 静态文件测试</span></span><br><span class=\"line\">ab -n 30 -c 10 <span class=\"string\">&#x27;http://127.0.0.1:8080/&#x27;</span></span><br><span class=\"line\">ab -n 300 -c 100 <span class=\"string\">&#x27;http://127.0.0.1:8080/&#x27;</span></span><br><span class=\"line\">ab -n 3000 -c 1000 <span class=\"string\">&#x27;http://127.0.0.1:8080/&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>测试结果</p>\n<ul>\n<li><p><code>/hello</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 30 -c 10 &#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /hello</span><br><span class=\"line\">Document Length:        14 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.075 seconds</span><br><span class=\"line\">Complete requests:      30</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      4680 bytes</span><br><span class=\"line\">HTML transferred:       420 bytes</span><br><span class=\"line\">Requests per second:    400.26 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       24.984 [ms] (mean)</span><br><span class=\"line\">Time per request:       2.498 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          60.98 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    0   0.1      0       0</span><br><span class=\"line\">Processing:     3   21  14.7     22      40</span><br><span class=\"line\">Waiting:        3   21  14.6     22      40</span><br><span class=\"line\">Total:          4   21  14.7     22      40</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     22</span><br><span class=\"line\">  66%     24</span><br><span class=\"line\">  75%     40</span><br><span class=\"line\">  80%     40</span><br><span class=\"line\">  90%     40</span><br><span class=\"line\">  95%     40</span><br><span class=\"line\">  98%     40</span><br><span class=\"line\">  99%     40</span><br><span class=\"line\"> 100%     40 (longest request)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 300 -c 100 &#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /hello</span><br><span class=\"line\">Document Length:        14 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      100</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.172 seconds</span><br><span class=\"line\">Complete requests:      300</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      46800 bytes</span><br><span class=\"line\">HTML transferred:       4200 bytes</span><br><span class=\"line\">Requests per second:    1748.63 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       57.188 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.572 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          266.39 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    1   1.3      0       4</span><br><span class=\"line\">Processing:    28   51  22.9     39     102</span><br><span class=\"line\">Waiting:       28   51  22.9     39     102</span><br><span class=\"line\">Total:         28   52  23.5     40     104</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     40</span><br><span class=\"line\">  66%     55</span><br><span class=\"line\">  75%     73</span><br><span class=\"line\">  80%     75</span><br><span class=\"line\">  90%     93</span><br><span class=\"line\">  95%     98</span><br><span class=\"line\">  98%    101</span><br><span class=\"line\">  99%    102</span><br><span class=\"line\"> 100%    104 (longest request)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 3000 -c 1000 &#x27;http://127.0.0.1:8080/hello&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /hello</span><br><span class=\"line\">Document Length:        14 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      1000</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.749 seconds</span><br><span class=\"line\">Complete requests:      3000</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      468000 bytes</span><br><span class=\"line\">HTML transferred:       42000 bytes</span><br><span class=\"line\">Requests per second:    4005.29 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       249.670 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.250 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          610.18 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    1   3.1      0      17</span><br><span class=\"line\">Processing:    19   32  17.6     28     131</span><br><span class=\"line\">Waiting:       19   32  17.6     28     131</span><br><span class=\"line\">Total:         20   32  20.2     28     140</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     28</span><br><span class=\"line\">  66%     30</span><br><span class=\"line\">  75%     32</span><br><span class=\"line\">  80%     33</span><br><span class=\"line\">  90%     44</span><br><span class=\"line\">  95%     81</span><br><span class=\"line\">  98%    125</span><br><span class=\"line\">  99%    134</span><br><span class=\"line\"> 100%    140 (longest request)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>/</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 30 -c 10 &#x27;http://127.0.0.1:8080/&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        121 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.091 seconds</span><br><span class=\"line\">Complete requests:      30</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      9240 bytes</span><br><span class=\"line\">HTML transferred:       3630 bytes</span><br><span class=\"line\">Requests per second:    329.41 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       30.358 [ms] (mean)</span><br><span class=\"line\">Time per request:       3.036 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          99.08 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    0   0.1      0       0</span><br><span class=\"line\">Processing:     5   27  17.5     27      50</span><br><span class=\"line\">Waiting:        5   27  17.4     27      49</span><br><span class=\"line\">Total:          6   27  17.5     27      50</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     27</span><br><span class=\"line\">  66%     29</span><br><span class=\"line\">  75%     49</span><br><span class=\"line\">  80%     49</span><br><span class=\"line\">  90%     50</span><br><span class=\"line\">  95%     50</span><br><span class=\"line\">  98%     50</span><br><span class=\"line\">  99%     50</span><br><span class=\"line\"> 100%     50 (longest request)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 300 -c 100 &#x27;http://127.0.0.1:8080/&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        121 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      100</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.187 seconds</span><br><span class=\"line\">Complete requests:      300</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      92400 bytes</span><br><span class=\"line\">HTML transferred:       36300 bytes</span><br><span class=\"line\">Requests per second:    1604.43 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       62.327 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.623 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          482.58 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    1   1.2      0       4</span><br><span class=\"line\">Processing:    22   57  37.2     46     133</span><br><span class=\"line\">Waiting:       21   57  37.2     46     133</span><br><span class=\"line\">Total:         22   58  38.1     46     134</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     46</span><br><span class=\"line\">  66%     52</span><br><span class=\"line\">  75%     95</span><br><span class=\"line\">  80%     96</span><br><span class=\"line\">  90%    125</span><br><span class=\"line\">  95%    131</span><br><span class=\"line\">  98%    133</span><br><span class=\"line\">  99%    134</span><br><span class=\"line\"> 100%    134 (longest request)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ab -n 3000 -c 1000 &#x27;http://127.0.0.1:8080/&#x27;</span></span><br><span class=\"line\">Server Software:        subhttpd/0.1</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            8080</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        121 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      1000</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.639 seconds</span><br><span class=\"line\">Complete requests:      3000</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      924000 bytes</span><br><span class=\"line\">HTML transferred:       363000 bytes</span><br><span class=\"line\">Requests per second:    4693.20 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       213.074 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.213 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          1411.63 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    1   2.7      0      15</span><br><span class=\"line\">Processing:    14   27  22.1     20     145</span><br><span class=\"line\">Waiting:       14   27  22.1     20     145</span><br><span class=\"line\">Total:         14   27  24.5     20     154</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%     20</span><br><span class=\"line\">  66%     22</span><br><span class=\"line\">  75%     23</span><br><span class=\"line\">  80%     26</span><br><span class=\"line\">  90%     45</span><br><span class=\"line\">  95%     59</span><br><span class=\"line\">  98%    137</span><br><span class=\"line\">  99%    148</span><br><span class=\"line\"> 100%    154 (longest request)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>结果分析</p>\n<p>本次测试所用的服务器性能比较强，但即使在这种情况下，以Apache为对比，对同一静态文件 <code>index.html</code> 在三种测试参数的最长完成时间分别为：<strong>1ms</strong>，<strong>10ms</strong>，<strong>33ms</strong>。可以看到在SubSpark的服务器在性能上距离工业级产品还有不小的距离。</p>\n<p>我准备后续继续做一些性能优化，目前正在准备用Netty重写 <code>HttpListener</code> 和 <code>HttpHandler</code> ，替换目前的BIO方案。</p>\n</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>像我一样的初级程序员最容易进入的误区之一就是过于重视<strong>编码</strong>而忽略了围绕项目周边的一系列建设。这个项目是我第一次用尽可能贴近工业界的标准来进行项目管理，包括统一规范的Git Message，单元测试，压力测试，文档编写，打包发布等。从中也能体会到做一个好的项目是多么不易。</p>\n<p>造出的轮子虽然难以进入生产环境，不过能在这一过程中经历到更标准的项目管理，钻研到协议规范，体会到工业级产品的实现难点倒也受益颇多，让我对servlet container的工作原理有了更深刻的认知。</p>\n","tags":["java"]},{"title":"使用Systemd进行自动部署","url":"/2021/02/25/%E4%BD%BF%E7%94%A8Systemd%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","content":"<p>作为实验室项目服务器的运 (bei) 维 (guo) 工 (xia) ，我长期经受着各种各样dirty工作的鞭打：频繁bug导致的重新部署、机房莫名奇妙的断电、nohup运行不优雅…</p>\n<p>终于，在又一次因机房断电重启服务后我决定做点什么来减轻一下自己的压力。于是我注意到了Systemd。</p>\n<a id=\"more\"></a>\n<h3 id=\"什么是Systemd？\"><a href=\"#什么是Systemd？\" class=\"headerlink\" title=\"什么是Systemd？\"></a>什么是Systemd？</h3><p>早期Linux使用SysVinit来做系统初始化，然而其具有着串行启动、功能单一诸多局限性，于是Systemd应运而生。它为系统的启动和管理提供了一套完整的解决方案。</p>\n<p>Systemd可以管理所有的系统资源，不同资源统称为Unit。Unit共12种，包括</p>\n<ul>\n<li>service: 系统服务</li>\n<li>target: 多个unit构成的组</li>\n<li>device: 硬件设备</li>\n<li>mount: 文件系统的挂载点</li>\n<li>automount: 自动挂载点</li>\n<li>path: 文件或路径</li>\n<li>scope: 不是由Systemd启动的外部进程</li>\n<li>slice: 进程组</li>\n<li>snapshot: Systemd快照，可以切回某个快照</li>\n<li>socket: 进程间通信的socket</li>\n<li>swap: swap文件</li>\n<li>timer: 定时器</li>\n</ul>\n<p>Systemd包括了一系列命令，本次使用到了<code>systemctl</code>和<code>journalctl</code>，前者为Systemd的主命令，后者用于操作Systemd的日志服务。下面是二者一些常用的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># systemctl常用命令</span></span><br><span class=\"line\"><span class=\"comment\"># 启动指定的服务</span></span><br><span class=\"line\">systemctl start foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭指定的服务</span></span><br><span class=\"line\">systemctl stop foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启指定的服务</span></span><br><span class=\"line\">systemctl restart foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重载指定的服务（支持时）</span></span><br><span class=\"line\">systemctl reload foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定服务的状态</span></span><br><span class=\"line\">systemctl status foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示指定unit的所有底层参数</span></span><br><span class=\"line\">systemctl show foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定服务的描述</span></span><br><span class=\"line\">systemctl cat foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在下次启动时或满足其他触发条件时设置服务为启用</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在下次启动时或满足其他触发条件时设置服务为禁用</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出可启动或停止的服务列表</span></span><br><span class=\"line\">systemctl list-unit-files --<span class=\"built_in\">type</span>=service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 服务配置变更时使用</span></span><br><span class=\"line\">systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># journalctl常用命令</span></span><br><span class=\"line\"><span class=\"comment\"># 查看所有日志</span></span><br><span class=\"line\">journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定时间的日志</span></span><br><span class=\"line\">journalctl --since <span class=\"string\">&quot;20 min ago&quot;</span></span><br><span class=\"line\">journalctl --since=<span class=\"string\">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class=\"line\">journalctl --since yesterday</span><br><span class=\"line\">journalctl --since <span class=\"string\">&quot;2015-01-10&quot;</span> --until <span class=\"string\">&quot;2015-01-11 03:00&quot;</span></span><br><span class=\"line\">journalctl --since 09:00 --until <span class=\"string\">&quot;1 hour ago&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看实时滚动的日志</span></span><br><span class=\"line\">journalctl -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看指定Unit的日志</span></span><br><span class=\"line\">journalctl -u foo.service</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示日志占据的硬盘空间</span></span><br><span class=\"line\">journalctl --disk-usage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定日志文件占据的最大空间</span></span><br><span class=\"line\">journalctl --vacuum-size=500M</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定日志文件的最长保存时间</span></span><br><span class=\"line\">journalctl --vacuum-time=2d</span><br></pre></td></tr></table></figure>\n<h3 id=\"service编写\"><a href=\"#service编写\" class=\"headerlink\" title=\"service编写\"></a>service编写</h3><p>服务器上需要配置的是一个前后端分离的web项目，二者独立更新，因此为二者分别编写service是更加灵活的选择。</p>\n<p>前端服务的配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># service-pattern-frontend.service</span></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Service Pattern System Frontend  <span class=\"comment\"># 服务描述</span></span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=150  <span class=\"comment\"># Start的最长等待时间</span></span><br><span class=\"line\">WorkingDirectory=/home/cbs/workspace/servicesysclient  <span class=\"comment\"># 工作目录</span></span><br><span class=\"line\">ExecStartPre=/usr/<span class=\"built_in\">local</span>/bin/npm run build  <span class=\"comment\"># Start前先执行build</span></span><br><span class=\"line\">ExecStart=/home/cbs/.yarn/bin/serve -s build -l 6052  <span class=\"comment\"># 启动监听</span></span><br><span class=\"line\">ExecStop=/bin/<span class=\"built_in\">kill</span> -INT <span class=\"variable\">$MAINPID</span>  <span class=\"comment\"># 使用SIGINT结束服务器的监听</span></span><br><span class=\"line\">RestartSec=15  <span class=\"comment\"># 重启前等待时间</span></span><br><span class=\"line\">Restart=on-failure  <span class=\"comment\"># 重启策略</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>后端服务的配置文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># service-pattern-backend.service</span></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Service Pattern System Backend  <span class=\"comment\"># 服务描述</span></span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">WorkingDirectory=/home/cbs/workspace/servicesysserver  <span class=\"comment\"># 工作目录</span></span><br><span class=\"line\">ExecStart=/home/cbs/anaconda3/bin/python manage.py runserver 0.0.0.0:6051  <span class=\"comment\"># 启动Django</span></span><br><span class=\"line\">ExecStop=/bin/<span class=\"built_in\">kill</span> -TERM <span class=\"variable\">$MAINPID</span>  <span class=\"comment\"># 使用SIGTERM结束服务器的监听</span></span><br><span class=\"line\">RestartSec=15  <span class=\"comment\"># 重启前等待时间</span></span><br><span class=\"line\">Restart=on-failure  <span class=\"comment\"># 重启策略</span></span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>简要介绍一下这两个service文件。首先看二者的相同部分</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># foo.service</span></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">...</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>[Unit]中的<code>After=network.target</code>表示当前服务需要在启动network.target之后才能启动。不过，由于项目中的前后端都跑在私有地址上，再通过端口映射暴露到外网，根据<a href=\"https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/\">NetWorkTarget</a>，不添加这一设置也是可行的，后面可以找时间再测试一下。</p>\n<p>[Install]中定义了<code>WantedBy=multi-user.target</code>，这一配置是服务实现开机自启动的关键。当执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> foo.service</span><br></pre></td></tr></table></figure>\n<p>时，<code>foo.service</code>将在<code>/etc/systemd/system/multi-user.target.wants</code>下创建一个符号链接。在终端环境下，<code>multi-user.target</code>是默认的启动target，这个组里的所有服务都将开机启动。</p>\n<h3 id=\"配置流程\"><a href=\"#配置流程\" class=\"headerlink\" title=\"配置流程\"></a>配置流程</h3><p>以前端的<code>service-pattern-frontend.service</code>为例，记录一下完整的配置流程。</p>\n<p>首先创建.service文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch service-pattern-frontend.service</span><br></pre></td></tr></table></figure>\n<p>并填入上面的配置内容。</p>\n<p>接着执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cp service-pattern-frontend.service /etc/systemd/system</span><br></pre></td></tr></table></figure>\n<p>将文件拷入保存service的目录中。</p>\n<p>此时输入<code>systemctl cat service-pattern-frontend.service</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(base) cbs@ubuntu:/$ systemctl cat service-pattern-frontend.service </span><br><span class=\"line\"><span class=\"comment\"># /etc/systemd/system/service-pattern-frontend.service</span></span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Service Pattern System Frontend</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=150</span><br><span class=\"line\">WorkingDirectory=/home/cbs/workspace/servicesysclient</span><br><span class=\"line\">ExecStartPre=/usr/<span class=\"built_in\">local</span>/bin/npm run build</span><br><span class=\"line\">ExecStart=/home/cbs/.yarn/bin/serve -s build -l 6052</span><br><span class=\"line\">ExecStop=/bin/<span class=\"built_in\">kill</span> -INT <span class=\"variable\">$MAINPID</span></span><br><span class=\"line\">RestartSec=15</span><br><span class=\"line\">Restart=on-failure</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>已经可以看到配置文件的内容。</p>\n<p>之后执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start service-pattern-frontend.service</span><br></pre></td></tr></table></figure>\n<p>启动服务。</p>\n<p><code>npm run build</code>的时间较长，因此在配置中额外设置了<code>TimeoutStartSec</code>，延长了等待时间。若未设置这一字段，Systemd将采用在<code>/etc/systemd/system.conf</code>中定义的<code>DefaultTimeoutStartSec=90s</code>。采用默认值可能使得<code>npm run build</code>来不及完成。</p>\n<p>启动成功后，输入<code>systemctl status service-pattern-frontend.service</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(base) cbs@ubuntu:/$ systemctl status service-pattern-frontend.service</span><br><span class=\"line\">● service-pattern-frontend.service - Service Pattern System Frontend</span><br><span class=\"line\">   Loaded: loaded (/etc/systemd/system/service-pattern-frontend.service; enabled; vendor preset: enabled)</span><br><span class=\"line\">   Active: active (running) since Fri 2021-02-26 01:26:48 CST; 14h ago</span><br><span class=\"line\">  Process: 26222 ExecStartPre=/usr/<span class=\"built_in\">local</span>/bin/npm run build (code=exited, status=0/SUCCESS)</span><br><span class=\"line\"> Main PID: 26422 (node)</span><br><span class=\"line\">    Tasks: 11 (<span class=\"built_in\">limit</span>: 4915)</span><br><span class=\"line\">   CGroup: /system.slice/service-pattern-frontend.service</span><br><span class=\"line\">           └─26422 node /home/cbs/.yarn/bin/serve -s build -l 6052</span><br><span class=\"line\"></span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You can also analyze the project dependencies: https://goo.gl/LeUzfb</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: The project was built assuming it is hosted at /.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You can control this with the homepage field <span class=\"keyword\">in</span> your package.json.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: The build folder is ready to be deployed.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You may serve it with a static server:</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]:   serve -s build</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: Find out more about deployment here:</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]:   bit.ly/CRA-deploy</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu systemd[1]: Started Service Pattern System Frontend.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu serve[26422]: INFO: Accepting connections at http://localhost:6052</span><br></pre></td></tr></table></figure>\n<p>可以看到前端服务已经启动成功。</p>\n<p>使用<code>journalctl -f -u service-pattern-frontend.service</code>可以查看启动日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(base) cbs@ubuntu:/$ journalctl -f -u service-pattern-frontend.service</span><br><span class=\"line\">-- Logs begin at Fri 2020-07-31 12:30:45 CST. --</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You can also analyze the project dependencies: https://goo.gl/LeUzfb</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: The project was built assuming it is hosted at /.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You can control this with the homepage field <span class=\"keyword\">in</span> your package.json.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: The build folder is ready to be deployed.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: You may serve it with a static server:</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]:   serve -s build</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]: Find out more about deployment here:</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu npm[26222]:   bit.ly/CRA-deploy</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu systemd[1]: Started Service Pattern System Frontend.</span><br><span class=\"line\">Feb 26 01:26:48 ubuntu serve[26422]: INFO: Accepting connections at http://localhost:6052</span><br></pre></td></tr></table></figure>\n<p>最后，使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> service-pattern-frontend.service</span><br></pre></td></tr></table></figure>\n<p>设置开机自启动，配置完毕。</p>\n<p>若对service文件有任何修改，记得使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<p>重新载入配置文件。</p>\n<p>由于后端服务有一功能会有大量std输出，曾经出现过40多G的nohup.out，因此每隔一段时间需要执行一下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo journalctl --vacuum-size=BYTES</span><br></pre></td></tr></table></figure>\n<p>清理日志文件。</p>\n<p>之后进行代码更新时，只需要重启一次服务即可，不用再kill，serve二连。日志也有了统一管理的工具，不需要再去nohup.out里一行行找。更重要的是，不用再担心哪天机房断电我又被叫去重启服务了，好耶！</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/systemd.service.html\">systemd.service</a></li>\n<li><a href=\"https://www.freedesktop.org/software/systemd/man/systemd.exec.html\">systemd.exec</a></li>\n<li><a href=\"https://www.freedesktop.org/wiki/Software/systemd/FrequentlyAskedQuestions/\">systemd/FAQ</a></li>\n<li><a href=\"https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/\">NetworkTarget</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html\">Systemd 入门教程：命令篇</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html\">Systemd 入门教程：实战篇</a></li>\n<li><a href=\"https://blog.csdn.net/mrmengj/article/details/112306151\">如何自定义自己的 systemd service 守护进程</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html\">浅析 Linux 初始化 init 系统: Systemd</a></li>\n</ul>\n","tags":["Linux"]},{"title":"机器学习 （1）绪论","url":"/2020/09/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%EF%BC%881%EF%BC%89%E7%BB%AA%E8%AE%BA/","content":"<p>积压了很久的🍉书笔记…</p>\n<a id=\"more\"></a>\n<h2 id=\"机器学习是什么？\"><a href=\"#机器学习是什么？\" class=\"headerlink\" title=\"机器学习是什么？\"></a>机器学习是什么？</h2><p>机器学习主要研究关于在计算机上从数据中产生“模型”的算法，即学习算法。</p>\n<p>有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型，在面对新的情况时，模型会给我们提供相应的判断。</p>\n<h2 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h2><h3 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h3><ul>\n<li><p><strong>样本</strong></p>\n<p>指对于一个事件或对象的描述。</p>\n<p>这样的描述通常反映了事件或对象在某些方面的特征和表现。描述的每一项被称为<strong>属性</strong>。属性上的取值称为<strong>属性值</strong>。属性张成的空间被称为<strong>属性空间、样本空间或输入空间</strong>。</p>\n<p> 对每个样本的描述通常由多个属性组成，属性的个数称为样本的<strong>维数</strong>。这些属性值可以表示为一个多维向量。因此一个样本也可被称为<strong>特征向量</strong>。每个特征向量都对应了样本空间中的一个点。</p>\n</li>\n<li><p><strong>数据集</strong></p>\n<p>多个样本的集合构成了一个<strong>数据集</strong>。</p>\n</li>\n<li><p><strong>训练集、训练样本</strong></p>\n<p>模型训练过程中使用的数据集被称为<strong>训练集</strong>。训练集中的样本被称为<strong>训练样本</strong>。</p>\n</li>\n<li><p><strong>样例</strong></p>\n<p>带有标记信息的样本被称为<strong>样例</strong>。一个样例通常可以用一个由特征向量和标记信息组成的二元组进行表示。</p>\n</li>\n</ul>\n<h3 id=\"学习任务\"><a href=\"#学习任务\" class=\"headerlink\" title=\"学习任务\"></a>学习任务</h3><ul>\n<li><p><strong>分类</strong></p>\n<p>若我们要预测的是<strong>离散值</strong>，则该任务称为<strong>分类</strong>。</p>\n</li>\n<li><p><strong>回归</strong></p>\n<p>若我们要预测的是<strong>连续值</strong>，则该任务称为<strong>回归</strong>。</p>\n</li>\n<li><p><strong>聚类</strong></p>\n<p>将训练集中的样本分成若干个组，每组称为一个“簇”。这样的任务被称为<strong>聚类</strong>。</p>\n<p>聚类学习中使用的样本通常<strong>不拥有标记信息</strong>。</p>\n</li>\n<li><p><strong>监督学习、无监督学习</strong></p>\n<p>根据训练数据<strong>是否含有标记信息</strong>，学习任务可大致划分为<strong>监督学习</strong>和<strong>无监督学习</strong>。</p>\n<p>分类和回归是前者的代表。</p>\n<p>聚类是后者的代表。</p>\n</li>\n<li><p><strong>泛化</strong></p>\n<p>学得模型适用于新样本的能力被称为<strong>泛化能力</strong>。</p>\n</li>\n</ul>\n<h2 id=\"假设空间\"><a href=\"#假设空间\" class=\"headerlink\" title=\"假设空间\"></a>假设空间</h2><ul>\n<li><p><strong>归纳</strong></p>\n<p>从特殊到一般，即从具体事实归结出一般性规律。例如<strong>从样例中学习</strong>。</p>\n<p>从样例中学习又称为<strong>归纳学习</strong>。</p>\n<p>狭义的归纳学习要求从训练样本中学得概念，因此也称<strong>概念学习</strong>。</p>\n</li>\n<li><p><strong>演绎</strong></p>\n<p>从一般到特殊，即从基础原理推演出具体情况。例如<strong>数学证明</strong>。</p>\n</li>\n</ul>\n<p>学习过程可以看作一个在所有假设组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设。可能有多个假设与训练集一致，即存在一个与训练集一致的“假设集合”，称之为<strong>版本空间</strong>。</p>\n<h2 id=\"归纳偏好\"><a href=\"#归纳偏好\" class=\"headerlink\" title=\"归纳偏好\"></a>归纳偏好</h2><p><strong>通过学习得到的模型对应了假设空间中的一个假设</strong>。</p>\n<p>由于版本空间中可能存在多个满足训练集的假设，而这些假设在面临新样本时却有可能产生不同的输出。对于一个具体的学习算法而言，其本身的<strong>“偏好”</strong>将决定最终选择哪一个假设作为最终的模型。</p>\n<p><strong>“奥卡姆剃刀原则”</strong>是一种可以使用的偏好，即“若有多个假设与观察一致，则选择最简单的那个”。</p>\n<p>事实上，归纳偏好对应了学习算法本身所做出的关于“什么样的模型更好”的假设。</p>\n<p>NFL定理指出，<strong>当所有“问题”出现的机会相同、或所有问题同等重要时，不同学习算法的期望性能是相同的</strong>。</p>\n<p><strong>NFL定理最重要的寓意在于，当考虑学习算法时应和具体问题相联系</strong>。</p>\n<h2 id=\"人工智能的发展历程\"><a href=\"#人工智能的发展历程\" class=\"headerlink\" title=\"人工智能的发展历程\"></a>人工智能的发展历程</h2><ul>\n<li><p><strong>推理期</strong></p>\n<p>20世纪50年代-70年代初</p>\n<p>只要能赋予机器逻辑推理的能力，机器就具有智能。</p>\n</li>\n<li><p><strong>知识期</strong></p>\n<p>20世纪70年代中期起</p>\n<p>要使机器具有智能，就必须设法使机器拥有知识。</p>\n<p>专家系统是该时期的产物。</p>\n</li>\n<li><p><strong>广义的归纳学习</strong></p>\n<p>20世纪80年代来被研究最多的、应用最广的是“从样例中学习”，即<strong>广义的归纳学习</strong>。其涵盖了<strong>监督学习、无监督学习</strong>等。这方面的主流技术包括：</p>\n<ul>\n<li><strong>符号主义学习</strong>，代表是<strong>决策树</strong>和<strong>基于逻辑的学习</strong>。</li>\n<li><strong>连接主义学习</strong>，代表是<strong>神经网络</strong>。</li>\n<li><strong>统计学习</strong>，代表是<strong>SVM</strong>和更一般的<strong>核方法</strong>。</li>\n<li><strong>深度学习</strong>，是连接主义学习的一个分支，狭义地说就是“很多层”的神经网络。</li>\n</ul>\n</li>\n</ul>\n","tags":["机器学习"]},{"title":"求余和取模","url":"/2020/08/21/%E6%B1%82%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1/","content":"<p>今天写题的时候遇到了两个异号数进行%运算的情形，研究了一下才发现求余和取模是不一样的。</p>\n<a id=\"more\"></a>\n<h3 id=\"计算公式\"><a href=\"#计算公式\" class=\"headerlink\" title=\"计算公式\"></a>计算公式</h3><p>A、B分别为被除数和除数。</p>\n<p>当A可以被B整除时，二者结果都为0。</p>\n<p>当A不可以被B整除时，令</p>\n<script type=\"math/tex; mode=display\">\nC = [A/B]</script><script type=\"math/tex; mode=display\">\nR = A - B*C</script><p>求余和取模都是求满足条件的R。但二者差别在于：</p>\n<p><strong>求余：使商C尽可能向0靠近。</strong></p>\n<p><strong>取模：使商C尽可能向负无穷靠近。</strong></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>取</p>\n<script type=\"math/tex; mode=display\">\nA = 7,\\space B=3</script><p>考虑小数，则</p>\n<script type=\"math/tex; mode=display\">\nC = A\\space/\\space B=7\\space/\\space 3 \\approx 2.3</script><p>取整后，产生了两个可能的商 2 和 3 。2 更靠近 0 ，也更靠近负无穷，因此无论求余还是取模，商都应该取 2 ，因此</p>\n<script type=\"math/tex; mode=display\">\nR = A-B*C=7-3*2=1</script><p>当A、B都取其相反数时同理。可以看出，<strong>当被除数和除数同号时，求余和取模的结果是一致的</strong>。</p>\n<p>若</p>\n<script type=\"math/tex; mode=display\">\nA=7,\\space B=-3</script><p>考虑小数，则</p>\n<script type=\"math/tex; mode=display\">\nC = A\\space/\\space B=7\\space/\\space (-3) \\approx -2.3</script><p>取整后，产生了两个可能的商 -2 和 -3 。由于 -2 更靠近 0 ，-3 更靠近负无穷，因此求余时商将取 -2，而取模时商将取 -3 。</p>\n<p>求余结果</p>\n<script type=\"math/tex; mode=display\">\nR = A-B*C=7-(-3)*(-2)=1</script><p>取模结果</p>\n<script type=\"math/tex; mode=display\">\nR = A-B*C=7-(-3)*(-3)=-2</script><p>当A、B都取相反数时同理。可以看出，<strong>当除数和被除数异号，求余和取模结果不一致</strong>。</p>\n<h3 id=\"简单的记忆方式\"><a href=\"#简单的记忆方式\" class=\"headerlink\" title=\"简单的记忆方式\"></a>简单的记忆方式</h3><p><strong>求余：</strong>余数和<strong>被除数</strong>同号。</p>\n<p><strong>取模：</strong>余数和<strong>除数</strong>同号。</p>\n<h3 id=\"不同语言中的\"><a href=\"#不同语言中的\" class=\"headerlink\" title=\"不同语言中的%\"></a>不同语言中的%</h3><p>C、C++、Java：求余</p>\n<p>Python：取模</p>\n"},{"title":"下岗工人的碎碎念","url":"/2020/03/14/%E4%B8%8B%E5%B2%97%E5%B7%A5%E4%BA%BA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/","content":"<p>还完工牌和电脑，三天前从北京回了家，我四个月的实习生活正式结束了。</p>\n<p><center><img src=\"/2020/03/14/%E4%B8%8B%E5%B2%97%E5%B7%A5%E4%BA%BA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/1.jpg\" width=\"50%\"></center><br><a id=\"more\"></a></p>\n<h3 id=\"从无业游民到打工仔\"><a href=\"#从无业游民到打工仔\" class=\"headerlink\" title=\"从无业游民到打工仔\"></a>从无业游民到打工仔</h3><p>刚进大学的时候，有时候会听说某某学长/学姐去了BAT。对于当时还只会写黑底白字cpp程序的我来说冲击不要太大，心中唯一的感觉是羡慕。知乎的焦虑轰炸和许多被夸大其词的“BAT面试题”让那时的我只觉得BAT只是一个遥不可及的梦。“读完本科和研究生能进个BAT就好了呀”。小白的梦想就是这么简单而枯燥。</p>\n<p>第一次听说头条是它和腾讯大战的时候。当时对这个公司并没有特别的感觉。过去挑战BAT的公司也不在少数，可人们记住的还是只有BAT。我寻思或许不久之后这家公司也将和前人无二，被时代的车轮碾过，不留痕迹。</p>\n<p>时间推移，国内互联网行业发展迅猛，自己也不再是那个认为互联网=BAT的一无所知的小白了，知道了还有规模和实力并不十分逊色于BAT的TMD，还知道了处于食物链顶端的FLAG。虽然不是只会用cpp写控制台了，但感觉自己离大厂距离还是很远。偶然又了解到头条特别舍得给钱，应届白菜能开出30+。对于当时只希望毕业之后能拿个20的offer的我来说又是一次大冲击。除了给钱多，同时了解到的是头条的面试也特别难，需要手撕算法题（后来才发现其实大厂都要）。从那个时候起，头条在我心中的地位已经和BAT差不多了，甚至还略高一点点？毕竟没有人和钱过不去嘛。</p>\n<p>到了大三下学期，随着对行业的进一步认知，以及和真正拿到大厂offer的学长的接触，这个时候我意识到并不是“人中龙凤”才有机会进大厂，我们普通人努努力也有机会。也知道了头条其实叫字节跳动，今日头条只是他们家其中一个产品。他们家还有一个爆款叫抖音。尽管很希望去看一看工业界的运作流程，了解一下大厂的做事方式，但由于要准备保研，这个念头也只能留在心里。那时心里根本不觉得保研和实习两件事可以兼顾。虽然听说上届有学长同时拿到了浙大CAD和腾讯的offer，但我只简单地把这种人归类于神仙。当时只想着能拿个交浙南的offer，大学圆满。</p>\n<p>真正意识到保研和实习是有可能兼顾的还是因为身边的同学。先是班上有两个同学先后拿到了字节跳动的前端和客户端实习offer，再到室友八月拿到抖音客户端的offer。直到突然有一天我发现，所有室友和另一个兄弟寝室的哥们全都找到了实习，只剩下了我一个无业游民，而他们也和我一样经历了保研中的所有事情。从小到大我们都在说环境会对人产生很大影响，此时此刻我终于有了深刻的感受。家长们为了把孩子送进名校争得头破血流大概也就出于这么个道理。我归因于好的环境会带来更强大的Peer Pressure，激起人的好胜心从而让人奋进。说白了就是你心里会想，大家学的都一样，他行凭啥我不行。</p>\n<h3 id=\"艰苦地找工地\"><a href=\"#艰苦地找工地\" class=\"headerlink\" title=\"艰苦地找工地\"></a>艰苦地找工地</h3><p>时间来到九月初，尽管保研还未尘埃落定，我心里却早已急不可耐，迫切地想找一份实习。加之室友也说面试时间可以约晚一点，所以虽然此时的我啥也没准备，忐忑之下还是把简历投了出去。最初我投递的都是一些小公司，想着先积累一些面试经验，为后续字节跳动的面试做准备。目标岗位是后端。</p>\n<p>第一次面试很快就来了，是杭州的一家小型公司，形式是电话面试。现在看来问的都是一些非常基础的知识，比如JVM的GC、Spring的IOC和AOP、MySQL的索引等等，甚至都没有算法题。然而那时啥都没准备，脑子空空的我自然是答得非常差。面试持续了三十分钟，在我一连串的“这个不太了解”中，面试官终于没能继续下去，最后意味深长说了句“不好意思，耽误你时间了啊”。后来一回想，大概是我耽误她时间了吧（狗头。</p>\n<p>总之第一次面试很失败，唯一的收获是让我认识到靠临阵磨枪是面不过后端岗的，要准备的知识太多，于是我决定把求职意向从后端改为客户端。一是考虑到目前字节跳动对客户端的需求比较大，机会更多，二是周围同学面的几乎也都是客户端，经验积累更多，三是客户端要准备的知识相较于后端稍微少一点。做完决定，改完简历，我又投了一波。为了给自己更大的压力，这次直接投的全是大厂，包括字节跳动。心里想着约完面试时间就能压迫自己准备了。字节跳动的面试邀约来的很快，我约了是9月底，等填完保研系统再顺手拿个offer，岂不美哉。</p>\n<p>事实证明，想法是美好的，现实往往没有那么顺利。时间来到了24号，我还在为保研的事忙得焦头烂额，《深入理解Java虚拟机》自然是没有翻开过的。意识到这种知识储备肯定要挂，我只能让HR把面试时间推迟到了国庆之后。</p>\n<p>填完系统，当早早拿到offer和不准备实习的同学们正准备享受即将到来的70周年国庆和阳光明媚，自由自在的大四生活时，我的苦日子才刚开始。国庆节当然是不存在的，我磕磕绊绊的把《深入理解Java虚拟机》中的重要内容过了一遍，看了看HashMap的源码解析，补了补Android的基础知识，再刷了几篇面经就匆忙上阵面试了。</p>\n<p>第一次面大厂，还要手撕代码，说不紧张那是假的。然而幸运的是，面试官的提问几乎全部精准命中我准备的内容。而且由于准备的时间很近，很多问题的细节都说得不错。面试结束立马就被告知HR会和我约二面的时间。人生嘛，总是起起落落落落落落的，我只等到了HR告诉我说觉得我实习时间太短，愿意走校招才安排二面。于是我的简历又回到了他们的简历海里。好在同学帮了大忙，让他们组把我简历又捞了起来，才总算是约上了二面。在等待二面的过程中还被百度捞了一次，来了一轮电话面。个人感觉百度的面试风格和字节很不一样，字节更注重计算机基础和算法，而百度则问了很多Android相关的知识，重要的组件几乎都问了个遍，另外还问了我准备得不多的数据库。当时Android的许多知识准备得还不太好，因此自然是没了下文。我倒也不太在意，就当给二面积累了点儿经验。</p>\n<p>二面的日子到了，这次几乎都在问Android，自然是存在知识死角。算法题来了两道，有一道写得不是特别好，因为边界条件的问题被怼了。最后的提问环节还傻乎乎的说之后考虑读博，让面试官觉得我来做客户端可能对双方帮助都不大。结果是我的简历又回到了简历海。得亏身边去字节的人多，三面被推到了我室友的部门。这一面除了Android知识的轰炸，还有一个鬼畜的情景题，问如何设计一个下载工具。面完我感觉就不是特别好，最后还是没有过，给的反馈是我面的这个HC是要做今日头条的，上手时间太长，我实习时间又太短。也不知是真的还是为了安慰我。此时能捞我的只剩下另一个在抖音的室友，但经过两轮打击，再加上抖音的要求肯定只会更高，我是没啥信心和动力再去他们组面一次的。再加上此时时间已经到了10月中旬，秋招都快结束了，我自觉再被其他组捞起来的希望渺茫。客户端的路也这么被堵死了。</p>\n<p>身边只剩下了一个做测试的同学。抱着死马当活马医的心态，我让他捞了一次，在一周之后等来了一个测开岗的面试邀约。这时的我早已不在意岗位，只要能进去啥岗都可以接受。在恶补了几天测试的基础知识之后，我最后的机会来了。一面二面紧挨着，二面中的一道算法题脑子一抽没做出来。幸亏自己争取了一下，让面试官补了一道，不然我可能真的会当一整学期无业游民。三面面试官是我后来的leader，他的面试是这段时间以来我经历的最魔幻的面试。开场就用一个“为什么电梯里摄像头要装在轿厢左后方的角落里？”把我问懵了。硬着头皮扯了几句之后又是两个很宽很大的问题，自觉答得也不怎么样。好在后面的两道代码题表现还不错，最后还是让我过了。第二天又经历了一轮HR面，耗时一整月，我终于找到了收留我搬砖的工地。</p>\n<h3 id=\"搬砖之旅\"><a href=\"#搬砖之旅\" class=\"headerlink\" title=\"搬砖之旅\"></a>搬砖之旅</h3><p>拿到offer，紧绷的心放松了不少，痛痛快快地和妹子去杭州溜达了一趟，顺便看好了要租的房子。在学期过去一半之后，我总算来到了北京，开始了实习生活。</p>\n<p>入职办理在中航广场，本以为入职就是交交材料，领一下电脑和工牌，一会儿就能结束，于是我饿着肚子就去了。没想到等着我的是一整个上午的入职会，和我一同办入职的新同学人数也远超我预料，整整坐满了会议室的两张大桌子。入职会的内容和我想的倒是差不多，无非就是身份查验，签合同，安装办公软件，看公司宣传片之类的事情。</p>\n<p>入职会结束的时候已经到了饭点，接我的HR却迟迟没到，最后还是我带着另外两个同在一栋办公楼的新同学过去的。也第一次知道了大公司还有着穿梭车这种东西，15分钟一班，往返在公司的各个办公点之间，相当于公司员工的免费公交车。我的办公点在紫金数码园。暑假参加过推免面试的软件所就在隔壁。当时就在附近看到过戴字节跳动工牌的人，没想到还挺有缘，最后自己也来了这里搬砖。</p>\n<p>饭后见了Leader和Mentor，认识了一下组内同学，了解到做的工作其实就是Web开发，准确的说是全栈开发，每个人都需要从前端写到后端。技术栈是Vue + Django。这俩我以前都没写过，因此接下来半个月也没有活，一直在配环境和学习，周末还能和同学们进城走一走，生活还是挺惬意的。</p>\n<p>摸鱼的日子也不好意思一直过下去，自己也想着过来应该要有点产出。正好Mentor把我派给了组内的另一个缺人力的同学，于是接到了我的第一个需求（实际上整个实习期都主要在做这个）。需求的大背景是当前公司内许多数据分散在不同的平台上，产品线的同学在发版前需要去各个平台都检查一遍，十分不便。我们的工作就是将这些数据整合到我们的测试平台上。我负责其中一个统计APP中各种Crash率的子模块。</p>\n<p>刚接到需求的时候其实有点overwhelmed，许多业内“黑话”我还没摸清，发版流程也不懂，再加上当时Vue才刚开始学，真的有点不知道从何下手。我也不太愿意问，一方面是想着同组同学都还有自己的工作，不好意思打扰人家，另一方面也是担心自己问的问题太傻，让人心里有想法，比如这都不知道，这个憨憨是怎么进来的。于是我就犟着自己盲人摸象，进度自然是很慢。后来在知乎看到一个同为刚进入字节的新同学写的一篇反思，里面说到刚入职的迷茫期就应该靠脸皮厚多问人度过。现在回想确实很有道理，你遇到的问题同组的同学大概率也有遇到，他们的一句指点往往能帮你直接解决问题。况且有些问题搜索引擎也不一定能找到答案，比如当牵扯到公司内部的库时。相比起那一点虚荣心，显然还是节省下来的那些时间更有价值。</p>\n<p>万事开头难，首先实现方案中就有许多细节等待落实。带我的同学认为需要利用定时任务爬取数据入我们的库，这里就引出了许多问题：定时任务的时间间隔设置为多久合适？爬取的数据量有多大？爬取的时间有多长？接口中哪些字段是我们需要的？这些只能靠着自己慢慢摸索，期间还碰到了没有接口文档，字段含义全靠猜测、爬取分页过大不返回结果、部分字段有时会因为编码问题无法存入数据库等一系列奇奇怪怪的问题。于是起码一周有余的时间我都花在了写数据爬取相关的逻辑上，最后花了半个月才写完第一版后端代码，换成在学校做课程设计黄花菜都凉了。好在带我的同学很宽容，给我排了很长的工期，赶在ddl前加了几天班，还是按时交工了。</p>\n<p>那时的我还不知道未来还有很长的返工的日子等着我。业务方无法接受定时任务带来的延时，要求数据和数据源平台完全同步。对方的数据库必然是拿不到的，因此只能改变方案，牺牲部分响应时间，请求时后端直接去数据源爬取，不再入库。这意味着整个后端逻辑几乎都要重写。Model层的代码完全失去作用，Service层代码也需要大改。加上期间业务方还在不断对模块提新需求和春节休假，导致这一个模块最终做到了二月中旬，前前后后弄了整整两个半月。吃过了苦头，对工作中沟通的重要性又有了新的认识。如果一开始就把各种细节都确定好，这次返工是完全可以避免的。</p>\n<p>房子只租到了三月初，加之自己也要准备毕业设计了，后续我只接了一个展示当前版本未合入代码的模块，业务逻辑也差不多，另外还完成了两个模块的国际化，便临近了离职的日子。遗憾的是，因为疫情原因，直到离职我也没能再进入一次办公楼。甚至交还电脑都是在中航园区保安处，连给矮楼再拍一张照片的机会都没有。</p>\n<h3 id=\"搬砖时的一些思考\"><a href=\"#搬砖时的一些思考\" class=\"headerlink\" title=\"搬砖时的一些思考\"></a>搬砖时的一些思考</h3><p>搬砖的时候我一直在想的一个问题是，如何判断一个研究方向是不是企业需要的呢？下面是我根据这段时间的观察得出的一些浅薄体会。</p>\n<p>岗位的需求要从企业的目标和组成出发。要明确的一点是国企和私企在这两个方面有着很大不同。ICT行业的龙头企业均为私企，因此这里的分析也只针对私企。又由于我入职的是技术类岗位，对其他如法务、人力、行政、运营之类的岗位不太了解，所以分析中涉及到的岗位也都限定在技术类。</p>\n<p>首先，私企最重要的目标当然是盈利。盈利是靠服务或产品创造的。举个例子，美团向外提供外卖服务，并从中赚取中间商差价。此外，他们还提供其他的服务，例如订机票、订酒店等等。最终这些服务都被整合到了一个叫美团的APP上，这就是他们的产品。事实上，大部分的服务最终都变成了看得见摸得着的产品，那么为什么还要单独强调“服务”这个概念呢？因为确实还存在着那么一些没办法具象化的话的东西，比如某些公司提供的一些咨询服务，他们利用专业知识和经验积累为客户提供解决方案。再举个例子，小明想要开一家公司，公司内部需要布置网络，而小明又不懂技术，这个时候他就可以向提供ICT技术咨询服务的公司求助，他们根据小明的需求告诉他需要买多少台服务器，各种设备应该选用什么样的配置，公司内应该怎么组网等等，甚至可以派人驻场直接帮助小明把这一切打理好，小明只需要找好团队公司就能直接运营了。这种服务的产物往往是一些意见，而且由于客户的需求不同会因人而异，不存在一个通用的模板，自然也不方便变成具象化的产品。</p>\n<p>企业依靠服务和产品盈利，除开维持公司正常运转的岗位，其余人员的组成一定是围绕它们展开的。因此，分析企业对岗位的需求可以从他们的产品出发。我把公司内的技术岗位分成两条线：<strong>业务线</strong>和<strong>支撑线</strong>。业务线团队是直接负责公司产品的研发的。以字节跳动的抖音为例，业务线就是直接负责抖音这个APP的团队，这个团队产出的代码最终打成包上架到各个应用商店，交付给用户。支撑线通常是为业务线提供工具或维护公司正常运转的团队，例如架构团队，他们负责整个公司基础设施的构建，包括各种数据中心，内网搭建，虚拟化等。再上层一点的团队负责公司通用组件的研发与维护，例如各种数据库、消息队列等中间件。总而言之，支撑线团队负责的是一些抽象程度高，通用性强的组件，相较于业务线更为底层。他们的产出不直接面向用户，而是作为开发的必要工具提供给业务线团队。另外，为了维护公司的正常运转，会存在着许许多多的内部系统，例如工资系统、报销系统、请假系统等等。当然换种角度看这些团队也可以被归到业务线，只是他们的产品是对内的，而不是对外的。再比如，算法团队也可以算到支撑线中。例如推荐算法团队提供封装好SDK供抖音业务线团队调用。还有一种特殊的支撑线是安全部门，负载保障公司和产品的信息安全。事实上，这种分析思想不仅仅适用于ICT行业中的技术岗，人力、行政、财务、法务等也都是为了保障公司的正常运转。</p>\n<p>了解了岗位分类，接下来就要落实到具体的岗位了。先说业务线，业务线所需岗位和产品的形式直接相关。如果产品是APP，那么客户端工程师肯定必不可少，同时，APP中会存在服务端的逻辑，所以也需要服务端工程师。此外，为了保证产品质量，还需要配套测试团队。如果产品是Web形式的，那就需要前端后端，客户端就没有需求了。再进一步，华为、小米等一些企业的产品是各种硬件设备，如手机电脑等，他们业务部门的组成又不一样了。以手机为例，可能有的团队负责OS，有的团队负责相机，有的团队负责通信模块、有的团队负责各种原生APP。根据团队职能不同其内设岗位将再进行细分。再说支撑线。在互联网企业中，支撑线提供的岗位大同小异，因为各种基础设施所有的公司都有需求。在当前上云已成为常态的背景下，这部分岗位主要来自IaaS和PaaS的需求，例如容器、负载均衡、数据库、缓存、消息队列、大数据平台等。</p>\n<p>此外，一些体量大，实力强的企业往往还会养一个研究团队，用于探索行业的前沿问题，以保持自己的行业领先地位。研究团队涉及到的方向大多还是和公司业务相关的，研究团队的人员往往也会积极寻求和业务部门的合作，用于落地研究成果。因为一个现实的问题是企业对这些部门的投入往往会大于他们为公司创造的看得见的价值。如果不积极寻求与业务部门的合作，当危机来临时这种部门往往会最先被裁掉。相反，业务线团队的被裁风险会相对较小，因为他们是直接为公司创造价值的团队。另外由于业务部门是直接面向用户的部门，交付压力会特别大。因为各种发版日期，产品的发布日期都是定死的，从而也导致了业务部门的加班风险很大。但收获往往和付出成正比，业务部门的年终奖相较于其他团队也会更多。</p>\n<h3 id=\"下岗后的打算\"><a href=\"#下岗后的打算\" class=\"headerlink\" title=\"下岗后的打算\"></a>下岗后的打算</h3><p>前前后后拖了半个月，这篇总结终于到了尾声。原本我设想只是简短的记录一下实习生活，没想到写着写着就成了6000字的大块头。而此刻毕设却还没有任何进展（似乎把精力花在了奇怪的地方）。</p>\n<p>最后到了Flag环节。这个学期的计划包括每天至少一道算法题（还没倒！），学完CSAPP，自学一下编译原理（是当初偷懒没选欠下的债）。最大的希望当然是赶快搞明白毕设，顺利毕业，早日和妹子、旁友们一起毕业旅行。</p>\n<p> End.</p>\n","tags":["随笔"]},{"title":"红包雨-红包分配方案设计","url":"/2021/12/11/%E7%BA%A2%E5%8C%85%E9%9B%A8-%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/","content":"<p>体验了一下字节的后端训练营，和小伙伴一起实现了一个红包雨系统的核心接口。这里记录一下我负责的红包分配方案设计。</p>\n<a id=\"more\"></a>\n<h2 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h2><p>春节红包雨是每年字节跳动最具挑战性的活动项目之一（除夕集中时间海量用户的参与）</p>\n<h3 id=\"需求说明\"><a href=\"#需求说明\" class=\"headerlink\" title=\"需求说明\"></a>需求说明</h3><p>语言不限，实现 3 个接口：<strong>抢红包接口</strong>、<strong>拆红包接口</strong>、<strong>钱包列表接口</strong></p>\n<ol>\n<li><p>抢红包接口</p>\n<ul>\n<li><p>每个用户最多只能抢到 N 次，次数可配</p>\n</li>\n<li><p>一定概率能抢到，概率可配置</p>\n</li>\n</ul>\n</li>\n<li>拆红包接口<ul>\n<li>把红包拆开入账到钱包</li>\n</ul>\n</li>\n<li><p>钱包列表接口</p>\n<ul>\n<li><p>显示总余额</p>\n</li>\n<li><p>显示抢到的红包，有已拆红包和未拆红包</p>\n</li>\n<li><p>按红包获取时间排序</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>红包雨的总金额、总个数、每个红包的金额范围可配置(配置文件)</p>\n<h2 id=\"红包分配方案\"><a href=\"#红包分配方案\" class=\"headerlink\" title=\"红包分配方案\"></a>红包分配方案</h2><p>红包的生成与分配是项目中非常重要的一环。一个好的方案应该能满足以下需求：</p>\n<ol>\n<li>尽可能把预算花完</li>\n<li>保证不超过预算</li>\n<li>当配置项临时变更时，仍应满足前三点需求</li>\n</ol>\n<p>我们精心设计了一套红包生成与分配的方案，若流量充足，可以使得配置的红包数分发完毕时，我们的方案可以使得配置的总金额<strong>正好消耗完毕</strong>。同时，我们还设计了“锦鲤”机制，可以让部分用户抽到大额的锦鲤红包，增加活动的趣味性。</p>\n<h3 id=\"可配置项\"><a href=\"#可配置项\" class=\"headerlink\" title=\"可配置项\"></a>可配置项</h3><ul>\n<li>普通红包总金额 <script type=\"math/tex\">M</script>（保存为分）</li>\n<li>普通红包个数 <script type=\"math/tex\">N</script></li>\n<li>金额范围 <script type=\"math/tex\">[min, max]</script></li>\n<li>用户最多可抢次数 <script type=\"math/tex\">k</script></li>\n<li>抢到概率 <script type=\"math/tex\">p</script></li>\n<li>锦鲤红包个数 <script type=\"math/tex\">F</script></li>\n<li>锦鲤红包金额 <script type=\"math/tex\">m_F</script></li>\n</ul>\n<p>由于引入了锦鲤红包，因此在我们的配置中需要对原始配置进行转换。设原始配置的红包总金额为<script type=\"math/tex\">M_0</script>，红包总个数为<script type=\"math/tex\">N_0</script>则转换公式为：</p>\n<script type=\"math/tex; mode=display\">\nM_0=M+F*m_F</script><script type=\"math/tex; mode=display\">\nN_0=N+F</script><p>我们为配置内容引入了合理的约束：</p>\n<script type=\"math/tex; mode=display\">\nmin <= M / (N-F) <= max</script><p>该约束非常好理解，假定普通红包均值小于设定的最小值，或大于设定的最大值，说明此时的配置并不合理。在红包金额限定在<script type=\"math/tex\">[min,max]</script>时，前者无法保证配置的总红包数消耗完，后者无法保证配置的总金额消耗完。</p>\n<h3 id=\"方案实现\"><a href=\"#方案实现\" class=\"headerlink\" title=\"方案实现\"></a>方案实现</h3><p>对于一次 <strong>抢红包接口（/snatch）</strong> 调用，我们将其分为三个阶段完成。第一个阶段检查用户当前抢的次数，第二个阶段以配置的概率为依据判断是否抢到，第三个阶段为判定抢红包成功的请求分配红包实例，包括红包id（<code>eid</code>）和红包金额</p>\n<h4 id=\"阶段一：抢红包次数检查\"><a href=\"#阶段一：抢红包次数检查\" class=\"headerlink\" title=\"阶段一：抢红包次数检查\"></a>阶段一：抢红包次数检查</h4><p>该阶段通过检查用户抢的次数，可以让一批无效的请求不进入后续的计算环节，减轻服务压力的同时还可以提高响应速度。</p>\n<p><strong>流程：</strong></p>\n<p>用<script type=\"math/tex\">S_{count}</script>表示调用用户当前抢的次数（用户第一次调用 <strong>/snatch</strong> 时设置为1）</p>\n<p>检查<script type=\"math/tex\">S_{count} \\le k</script>是否满足：</p>\n<ul>\n<li>若满足，令 <script type=\"math/tex\">S_{count} = S_{count} + 1</script>，进入第二阶段</li>\n<li>若不满足，直接返回抢红包失败</li>\n</ul>\n<h4 id=\"阶段二：判断是否抢到\"><a href=\"#阶段二：判断是否抢到\" class=\"headerlink\" title=\"阶段二：判断是否抢到\"></a>阶段二：判断是否抢到</h4><p>该阶段通过对<script type=\"math/tex\">p</script>做预处理，判定某一次成功的调用（即通过阶段一）是否抢到红包。</p>\n<p><strong>流程：</strong></p>\n<p>令<script type=\"math/tex\">a / b = p / 1</script>，其中<script type=\"math/tex\">a，b</script>均为整数，且<script type=\"math/tex\">a / b</script>不可再约分</p>\n<p>维护一个全局的请求计数器<script type=\"math/tex\">C</script>，计算<script type=\"math/tex\">C\\ mod\\ b</script>:</p>\n<ul>\n<li>若<script type=\"math/tex\">C\\ mod\\ b < a</script>，判定本次抢红包成功，进入阶段三</li>\n<li>若<script type=\"math/tex\">C\\ mod\\ b \\ge a</script>，判定本次抢红包失败</li>\n</ul>\n<p>计算完成后，令<script type=\"math/tex\">C=C+1</script></p>\n<p>我们的方案规避了随机数库的不可控性，当流量足够大时，可以严格保证每次成功的调用抢到红包的概率是<script type=\"math/tex\">p</script>，同时实现也相对简单。</p>\n<p><strong>核心代码：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gcd</span><span class=\"params\">(x, y <span class=\"keyword\">int64</span>)</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> x%y == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> y</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> gcd(y, x%y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadStrategy</span><span class=\"params\">(p <span class=\"keyword\">float64</span>)</span> <span class=\"params\">(<span class=\"keyword\">int64</span>, <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> b <span class=\"keyword\">int64</span> = <span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> p != <span class=\"keyword\">float64</span>(<span class=\"keyword\">int64</span>(p)) &#123;</span><br><span class=\"line\">      b *= <span class=\"number\">10</span></span><br><span class=\"line\">      p *= <span class=\"number\">10</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   a := <span class=\"keyword\">int64</span>(p)</span><br><span class=\"line\">   d := gcd(b, a)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a / d, b / d</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">testSnatching</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">   next := atomic.AddInt64(&amp;C, <span class=\"number\">1</span>)</span><br><span class=\"line\">   cur := next - <span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> cur%a &lt; b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在实际的编码中，我们采用原子操作来进行请求计数器<script type=\"math/tex\">C</script>的自增，无需加锁的开销。</p>\n<h4 id=\"阶段三：红包金额分配\"><a href=\"#阶段三：红包金额分配\" class=\"headerlink\" title=\"阶段三：红包金额分配\"></a>阶段三：红包金额分配</h4><p>该阶段为成功抢到的红包分配红包id（表示为 <code>eid</code> ）和红包金额。</p>\n<h5 id=\"红包id生成\"><a href=\"#红包id生成\" class=\"headerlink\" title=\"红包id生成\"></a>红包id生成</h5><p>由于我们的应用最终要进行多实例部署，如何在分布式环境中保证 <code>eid</code> 的全局唯一性就成了这一阶段的重点。最终，我们的实现方案是 <strong>Redis分布式锁 + 分段申请</strong>，最终生成的 <code>eid</code> 范围为<script type=\"math/tex\">[1,N+F]</script></p>\n<p>Redis中会维护一条<strong>剩余红包数</strong>的记录，在应用启动时，Redis会从配置文件中读取总红包个数<script type=\"math/tex\">N+F</script>，并将其设置到<strong>剩余红包数</strong>的记录中。</p>\n<p>每个实例启动后调用<strong>eid申请函数</strong>，其首先会获取一个由Redis实现的分布式锁，之后读取Redis中的剩余红包数<script type=\"math/tex\">R</script>，则可以根据总红包数计算已分配的红包数<script type=\"math/tex\">A=N-R</script>，此时下一个可用的 <code>eid</code> 即为<script type=\"math/tex\">A+1</script>。之后，申请函数会尝试申请一段长度为<script type=\"math/tex\">CacheCapacitiy</script>的 <code>eid</code> ，并设置<script type=\"math/tex\">R=R-CacheCapacity</script>，最终本次申请到的 <code>eid</code> 范围为<script type=\"math/tex\">[A+1,A+CacheCapacity]</script>，两个边界将被设置到实例本地。若剩余红包数<script type=\"math/tex\">R<CacheCapacitiy</script>，则直接申请到边界，即最终申请到的 <code>eid</code> 范围为<script type=\"math/tex\">[A+1,R]</script>，并设置<script type=\"math/tex\">R=0</script>。后续的实例再进行申请时发现已没有剩余红包，则会设置本地的<strong>已发完</strong>标记，后续的 <strong>/snatch</strong> 调用都不再成功。</p>\n<p>分段申请的设计可以减少分布式锁的加锁次数，提高系统性能。</p>\n<p>每个实例还会在本地维护一个<script type=\"math/tex\">offset</script>变量，用于标记下一个使用的 <code>eid</code> 相较于起始 <code>eid</code> 的偏移量。当请求达到时，每个实例会更新<script type=\"math/tex\">offset</script>，并利用其分配 <code>eid</code>。</p>\n<h5 id=\"锦鲤红包的判定\"><a href=\"#锦鲤红包的判定\" class=\"headerlink\" title=\"锦鲤红包的判定\"></a>锦鲤红包的判定</h5><p>在我们的方案中，锦鲤红包的个数和金额都是固定的，且锦鲤红包个数只占所有红包中很小一部分，因此我们的方案是在<script type=\"math/tex\">[1,N]</script>中设置<script type=\"math/tex\">F</script>个等分点，等分点对应的 <code>eid</code> 则判定为锦鲤红包。由于最终的请求流量是随机的，因此抢到锦鲤红包的用户也是随机的。</p>\n<h5 id=\"红包金额生成\"><a href=\"#红包金额生成\" class=\"headerlink\" title=\"红包金额生成\"></a>红包金额生成</h5><p>在完成 <code>eid</code> 申请后，金额生成算法会为所有 <code>eid</code> 生成一个满足配置的金额。金额要么落在<script type=\"math/tex\">[min,max]</script>中，要么为<script type=\"math/tex\">m_F</script>。</p>\n<p>Redis中会维护一条<strong>普通红包金额均值</strong>的记录，与剩余红包数类似，同样在应用启动时写入。</p>\n<p>每次 <code>eid</code> 申请完成后，按如下流程为每个 <code>eid</code> 分配红包金额：</p>\n<ol>\n<li><p>读取Redis中的<strong>普通红包金额均值</strong><script type=\"math/tex\">Avg</script></p>\n</li>\n<li><p>每次生成一对红包，金额分别为<script type=\"math/tex\">Avg-i, Avg+i</script>，其中<script type=\"math/tex\">i \\in N</script>且<script type=\"math/tex\">Avg-i \\ge min, Avg+i \\le max</script></p>\n<p>如果 <code>eid</code> 对应的是普通红包，则按以上规则生成；如果一对红包中有一个 <code>eid</code> 命中了锦鲤红包的 <code>eid</code>，则为其分配金额 <script type=\"math/tex\">m_F</script>，同时为另一个红包分配金额<script type=\"math/tex\">Avg</script></p>\n</li>\n<li><p>循环多次，直到最终为所有申请到的 <code>eid</code> 分配好金额。如果最后剩下一个红包，则根据其是否为锦鲤红包 <code>eid</code> 为其分配金额<script type=\"math/tex\">m_F</script>或<script type=\"math/tex\">Avg</script></p>\n</li>\n</ol>\n<p>除锦鲤红包外，该方案可以保证每一次的<strong>原子生成</strong>（即生成一对或一个）都不会让剩余普通红包的均值发生变化，因此可以保证当红包数消耗完时，红包总金额也正好消耗完。</p>\n<p><strong>核心代码：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FunctionConfiguration <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   Times       <span class=\"keyword\">int32</span></span><br><span class=\"line\">   Probability <span class=\"keyword\">float64</span></span><br><span class=\"line\">   Amount      <span class=\"keyword\">int32</span></span><br><span class=\"line\">   Envelope    <span class=\"keyword\">int32</span></span><br><span class=\"line\">   Min         <span class=\"keyword\">int32</span></span><br><span class=\"line\">   Max         <span class=\"keyword\">int32</span></span><br><span class=\"line\">   LuckyCount  <span class=\"keyword\">int32</span></span><br><span class=\"line\">   LuckyMoney  <span class=\"keyword\">int32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SnatchService <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   cfg                         FunctionConfiguration</span><br><span class=\"line\">   runOut                      <span class=\"keyword\">bool</span></span><br><span class=\"line\">   eidStart, eidEnd, eidOffset <span class=\"keyword\">int32</span></span><br><span class=\"line\">   valueCache                  []<span class=\"keyword\">int32</span></span><br><span class=\"line\">   valueLock                   sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缓存创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SnatchService)</span> <span class=\"title\">createValueCache</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   identifier, _ := redisService.DLock(dLockKey)</span><br><span class=\"line\">   remaining, _ := redisService.GetRemainEnvelopeAmount()</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// eid starts from 1</span></span><br><span class=\"line\">   s.eidStart = s.cfg.Envelope - remaining + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// No available eid</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> s.eidStart &gt; s.cfg.Envelope &#123;</span><br><span class=\"line\">      log.Info(<span class=\"string\">&quot;Run out of envelopes.&quot;</span>)</span><br><span class=\"line\">      s.runOut = <span class=\"literal\">true</span></span><br><span class=\"line\">      _, _ = redisService.DUnlock(identifier, dLockKey)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Calculate eid end of this allocation</span></span><br><span class=\"line\">   s.eidEnd = s.eidStart + cacheCapacity - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Not enough eid</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> s.eidEnd &gt; s.cfg.Envelope &#123;</span><br><span class=\"line\">      s.eidEnd = s.cfg.Envelope</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   N := s.eidEnd - s.eidStart + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Update remaining</span></span><br><span class=\"line\">   _ = redisService.SetRemainEnvelopeAmount(remaining - N)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Read current average value</span></span><br><span class=\"line\">   avg, _ := redisService.GetAvgValue()</span><br><span class=\"line\">   _, _ = redisService.DUnlock(identifier, dLockKey)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> N &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      log.Info(fmt.Sprintf(<span class=\"string\">&quot;Get eid range [%v, %v]\\n&quot;</span>, s.eidStart, s.eidEnd))</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   s.eidOffset = <span class=\"number\">0</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">// Generate value of envelopes</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> idx := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); idx &lt; N; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> i := <span class=\"keyword\">int32</span>(<span class=\"number\">0</span>); idx &lt; N &amp;&amp; avg-i &gt;= s.cfg.Min &amp;&amp; avg+i &lt;= s.cfg.Max; i++ &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> idx+<span class=\"number\">1</span> &lt; N &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Eid &lt;- [1, Amount], Mod &lt;- [0, Amount)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.eidStart+idx<span class=\"number\">-1</span>)%s.luckyRound != <span class=\"number\">0</span> &amp;&amp; (s.eidStart+idx)%s.luckyRound != <span class=\"number\">0</span> || s.eidStart+idx<span class=\"number\">-1</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">               s.valueCache[idx] = avg - i</span><br><span class=\"line\">               s.valueCache[idx+<span class=\"number\">1</span>] = avg + i</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">// If lucky eid is met, two red envelopes with value luckyValue and avgValue will be created</span></span><br><span class=\"line\">               <span class=\"keyword\">var</span> lucky, another <span class=\"keyword\">int32</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (s.eidStart+idx)%s.luckyRound == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                  lucky = idx</span><br><span class=\"line\">                  another = idx + <span class=\"number\">1</span></span><br><span class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  lucky = idx + <span class=\"number\">1</span></span><br><span class=\"line\">                  another = idx</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               s.valueCache[lucky] = s.cfg.LuckyMoney</span><br><span class=\"line\">               s.valueCache[another] = avg</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            idx += <span class=\"number\">2</span></span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> idx &lt; N &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.eidStart+idx)%s.luckyRound != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">               s.valueCache[idx] = avg</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               s.valueCache[idx] = s.cfg.LuckyMoney</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获得下一个红包的eid和金额</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SnatchService)</span> <span class=\"title\">nextRedEnvelope</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">int32</span>, <span class=\"keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">   s.valueLock.Lock()</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> s.valueLock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> s.eidOffset &gt; s.eidEnd-s.eidStart &#123;</span><br><span class=\"line\">      s.createValueCache()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> s.runOut &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>, <span class=\"number\">-1</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   eid, value := s.eidStart+s.eidOffset, s.valueCache[s.eidOffset]</span><br><span class=\"line\">   s.eidOffset++</span><br><span class=\"line\">   <span class=\"keyword\">return</span> eid, value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"应对配置更新\"><a href=\"#应对配置更新\" class=\"headerlink\" title=\"应对配置更新\"></a>应对配置更新</h3><p>配置更新时需要完成两件事：一是更新Redis中的共享变量（剩余红包数、普通红包均值），二是更新各个实例的本地变量。</p>\n<h4 id=\"Redis更新\"><a href=\"#Redis更新\" class=\"headerlink\" title=\"Redis更新\"></a>Redis更新</h4><p>在多实例环境下，Redis更新的难点在于需要实现一种“仅写一次”的机制，即仅由一个实例完成写，但所有实例都需要读。</p>\n<p>我们通过一种基于版本的方式来实现这一机制。我们引入了 <code>Version</code> 字段，用于描述配置的版本。每次更新时填入的版本号自增。<code>Version</code> 字段同时存在于Redis和配置文件中。和剩余红包数等共享变量类似，<code>Version</code> 会在应用初始化时从配置文件读入到Redis中。</p>\n<p>每次触发配置更新的回调时，所有实例首先读取Redis中的 <code>Version</code> 字段，比较其和新配置文件中 <code>Version</code> 字段的大小。若前者等于后者，说明Redis中的配置已经被修改，当前实例无需再次写入。若前者小于后者，说明此时Redis中的配置尚未被修改，当前实例将尝试获取分布式锁。实例获取到锁后，将再一次对二者进行比较（双检锁），若仍满足前者小于后者，将执行写Redis操作。写完毕后，更新Redis中的 <code>Version</code> 字段，并释放分布式锁。</p>\n<p>写Redis实质就是依据新配置更新共享变量<strong>剩余红包数</strong><script type=\"math/tex\">R</script>和<strong>普通红包均值</strong><script type=\"math/tex\">Avg</script>。由于更新Redis的实例此时持有老版本配置，因此可以依据普通红包总数<script type=\"math/tex\">N</script>计算出已发放的普通红包数<script type=\"math/tex\">S</script>。由于我们的方案保证了金额分配中<script type=\"math/tex\">Avg</script>的值不变，因此使用<script type=\"math/tex\">Avg*S</script>就可以计算出已发普通红包的金额。此时，无论是已发放的红包数还是已发放的金额，都有可能大于等于新配置中的对应量。若检查到这种情况，说明此时在新配置下已经超发，Redis中的<script type=\"math/tex\">R</script>和<script type=\"math/tex\">Avg</script>都将被设为0。若二者都小于新配置，通过减去已发放的，我们可以计算出新的<script type=\"math/tex\">R</script>和<script type=\"math/tex\">Avg</script>，并将二者更新到Redis中。我们还对新配置增加了约束检查。当新的<script type=\"math/tex\">Avg</script>小于新的<script type=\"math/tex\">min</script>时，我们将设置<script type=\"math/tex\">Avg=min</script>，即始终以<script type=\"math/tex\">min</script>的面额发放红包，直到把预算消耗完（此时配置的红包数有剩余）。当新的<script type=\"math/tex\">Avg</script>大于<script type=\"math/tex\">max</script>时，我们将设置<script type=\"math/tex\">Avg=max</script>，即始终以<script type=\"math/tex\">max</script>的面额发放红包，直到把配置的红包数消耗完（此时预算有剩余）。</p>\n<h4 id=\"本地变量更新\"><a href=\"#本地变量更新\" class=\"headerlink\" title=\"本地变量更新\"></a>本地变量更新</h4><p>每个实例在完成上一步后，需要依据新的配置对本地变量进行更新。这一步相对简单，只需读取Redis中的剩余红包数，检查新配置是否超发（为0），若超发，设置<strong>已发完</strong>标记，之后的发红包请求将直接失败。若未超发，将新配置中的变量覆盖本地变量即可。</p>\n<p>由于Local Cache的存在，配置更新并不会立刻生效。当实例把消耗完Local Cache，就会按照新的配置进行红包申请了。</p>\n<p><strong>核心代码：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">s := <span class=\"built_in\">new</span>(SnatchService)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callback</span><span class=\"params\">(cfg config.Configuration)</span></span> &#123;</span><br><span class=\"line\">   log.Info(<span class=\"string\">&quot;Reloading function configuration...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Keep this order of acquiring lock to avoid deadlock</span></span><br><span class=\"line\">   <span class=\"comment\">// valueLock -&gt; DLock</span></span><br><span class=\"line\">   s.valueLock.Lock()</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> s.valueLock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">   oldCfg := s.cfg</span><br><span class=\"line\">   newCfg := cfg.Function</span><br><span class=\"line\">   <span class=\"keyword\">var</span> nowVersion <span class=\"keyword\">int32</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// nowVersion == newCfg.Version means Redis has been updated,</span></span><br><span class=\"line\">   <span class=\"comment\">// there is no need to acquire lock again</span></span><br><span class=\"line\">   nowVersion, _ = redisService.GetFunctionVersion()</span><br><span class=\"line\">   <span class=\"keyword\">if</span> nowVersion &lt; newCfg.Version &#123;</span><br><span class=\"line\">      identifier, _ := redisService.DLock(dLockKey)</span><br><span class=\"line\">      nowVersion, _ = redisService.GetFunctionVersion()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Double check lock</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> nowVersion &lt; newCfg.Version &#123;</span><br><span class=\"line\">         remainingEnvelope, _ := redisService.GetRemainEnvelopeAmount()</span><br><span class=\"line\">         avg, _ := redisService.GetAvgValue()</span><br><span class=\"line\"></span><br><span class=\"line\">         allocatedEnvelope := oldCfg.Envelope - remainingEnvelope</span><br><span class=\"line\">         allocatedAmount := allocatedEnvelope * avg</span><br><span class=\"line\"></span><br><span class=\"line\">         newRemainingEnvelope := newCfg.Envelope - allocatedEnvelope</span><br><span class=\"line\">         newRemainingAmount := newCfg.Amount - allocatedAmount</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> newRemainingEnvelope &lt;= <span class=\"number\">0</span> || newRemainingAmount &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Allocated red envelopes have exceeded new configuration</span></span><br><span class=\"line\">            _ = redisService.SetRemainEnvelopeAmount(<span class=\"number\">0</span>)</span><br><span class=\"line\">            _ = redisService.SetAvgValue(<span class=\"number\">0</span>)</span><br><span class=\"line\">            log.Warn(<span class=\"string\">&quot;Configuration mismatch: allocated red envelopes have exceeded new configuration.&quot;</span>)</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Update average value for future local cache</span></span><br><span class=\"line\">            newAvg := newRemainingAmount / newRemainingEnvelope</span><br><span class=\"line\">            <span class=\"keyword\">if</span> newAvg &lt; newCfg.Min &#123;</span><br><span class=\"line\">               newAvg = newCfg.Min</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">// Decrease the number of envelopes to keep the consistency</span></span><br><span class=\"line\">               <span class=\"comment\">// avg * remaining == remaining amount</span></span><br><span class=\"line\">               newRemainingEnvelope = newRemainingAmount / newCfg.Min</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> newAvg &gt; newCfg.Max &#123;</span><br><span class=\"line\">               newAvg = newCfg.Max</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            _ = redisService.SetRemainEnvelopeAmount(newRemainingEnvelope)</span><br><span class=\"line\">            _ = redisService.SetAvgValue(newAvg)</span><br><span class=\"line\">            log.Info(fmt.Sprintf(<span class=\"string\">&quot;New configuration loaded, RemainingEnvelopes: %v , Avg: %v\\n&quot;</span>, newRemainingEnvelope, newAvg))</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// Update configuration version in Redis</span></span><br><span class=\"line\">         _ = redisService.SetFunctionVersion(newCfg.Version)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      _, _ = redisService.DUnlock(identifier, dLockKey)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Update local variables</span></span><br><span class=\"line\">   s.updateConfiguration(newCfg)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *SnatchService)</span> <span class=\"title\">updateConfiguration</span><span class=\"params\">(cfg config.FunctionConfiguration)</span></span> &#123;</span><br><span class=\"line\">   remainingEnvelope, _ := redisService.GetRemainEnvelopeAmount()</span><br><span class=\"line\">   s.runOut = remainingEnvelope == <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> s.runOut &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Invalidate local cache</span></span><br><span class=\"line\">      s.eidOffset = <span class=\"number\">0</span></span><br><span class=\"line\">      s.eidEnd = <span class=\"number\">-1</span></span><br><span class=\"line\">      s.eidStart = <span class=\"number\">0</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   s.loadConfiguration(cfg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}]