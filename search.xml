<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSAPP 01 - Bits, Bytes and Integers</title>
    <url>/2020/06/28/CSAPP-01-Bits-Bytes-and-Integers/</url>
    <content><![CDATA[<p>Notes for Bits, Bytes and Integers.</p>
<a id="more"></a>
<h3 id="用bit来表示和操纵集合"><a href="#用bit来表示和操纵集合" class="headerlink" title="用bit来表示和操纵集合"></a>用bit来表示和操纵集合</h3><p>宽为 $w$ 的bit向量可用于表示 $A=\{0,\cdots,w-1\}$ 的子集，$j \in A$ 当且仅当 $a_j=1$。</p>
<p>例如，01101001可表示 $\{0, 3, 5, 6\}$；01010101可表示 $\{0, 2, 4, 6\}$。</p>
<p>&amp;，｜，~可分别求集合的交、并、补集。</p>
<p><strong>注：</strong> C++提供了bitset库用于管理一系列的bit位。</p>
<h3 id="有符号数的计算公式"><a href="#有符号数的计算公式" class="headerlink" title="有符号数的计算公式"></a>有符号数的计算公式</h3><script type="math/tex; mode=display">
-x_{w-1}\cdot2^{w-1}+\sum_{i=0}^{w-2}x_i\cdot2^i</script><p>其中 $w$ 是位宽，最高位第$w-1$是符号位。</p>
<h3 id="C中的无符号数"><a href="#C中的无符号数" class="headerlink" title="C中的无符号数"></a>C中的无符号数</h3><ol>
<li><p><strong>int和unsigned相互转换</strong></p>
<p>保留bit模式，但根据符号位的不同含义重新翻译其值。</p>
<p>int和unsigned出现在同一个表达式时，int会被隐式转换成unsigned，从而可能导致一些混乱。</p>
<p>例如：</p>
<p>-1 &lt; 0</p>
<p>-1 &gt; 0U</p>
</li>
<li><p><strong>一段危险的代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = cnt - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    a[i] = a[i + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>unsigned始终不小于0。当其等于0时，再进行一次自减将变成UINT_MAX，从而导致死循环。</p>
<p>sizeof默认返回unsigned，在使用其返回值时同样应注意以上代码的问题。</p>
<p>若想要使用unsigned作为循环索引，正确的姿势是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = cnt - <span class="number">2</span>; i &lt; cnt; i--)</span><br><span class="line">    a[i] = a[i + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="有符号数的位扩展与截断"><a href="#有符号数的位扩展与截断" class="headerlink" title="有符号数的位扩展与截断"></a>有符号数的位扩展与截断</h3></li>
<li><p><strong>位扩展</strong></p>
<p>用现有最高位填充所有扩展位。如short ➡️ int时会发生。</p>
</li>
<li><p><strong>位截断</strong></p>
<p>直接截去多余的位，可能出现正数变负数，负数变正数。如int ➡️ short时会发生。</p>
</li>
</ol>
<h3 id="移位计算"><a href="#移位计算" class="headerlink" title="移位计算"></a>移位计算</h3><ol>
<li><strong>左移</strong><ul>
<li>$u &lt;&lt; k = u * 2^k$</li>
<li>对于有符号数和无符号数都适用</li>
</ul>
</li>
<li><strong>右移</strong><ul>
<li>无符号数采用逻辑移位，有 $u &gt;&gt; k = \lfloor u / 2^k \rfloor$</li>
<li>有符号数采用算术移位，有 $u &gt;&gt; k = \lceil u / 2^k \rceil$</li>
<li>无符号数的右移等价于除以对应2的幂，有符号数不等价（会向错误的方向进位）</li>
</ul>
</li>
</ol>
<h3 id="何时使用无符号数？"><a href="#何时使用无符号数？" class="headerlink" title="何时使用无符号数？"></a>何时使用无符号数？</h3><ul>
<li>进行模运算时</li>
<li>当使用bit来表示集合时</li>
<li>在系统编程中：bit masks、device commands…</li>
</ul>
]]></content>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 02 - Floating Point</title>
    <url>/2020/11/07/CSAPP-02-Floating-Point/</url>
    <content><![CDATA[<p>Notes for Floating Point.</p>
<a id="more"></a>
<h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>对于小数</p>
<script type="math/tex; mode=display">
b_mb_{m-1} \dots b_1b_0.b_{-1}b_{-2} \dots b_{-n-1}b_{-n}</script><p>其中 $b_i$ 取 0 或 1，则其值 $b$ 为</p>
<script type="math/tex; mode=display">
b=\sum_{i=-n}^{m}2^{i} \cdot b_i</script><p>在编码长度有限的条件下，这种表示法只能表示那些能被写成形如 $x \cdot 2^y$ 的数。而对于无法写成这种形式的数只能进行近似表示，如 1/5。</p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>一个浮点数 $V$ 表示为</p>
<script type="math/tex; mode=display">
V=(-1)^s \times M \times 2^E</script><ul>
<li>$s$ ：符号位，正数为1，负数为0。</li>
<li>$M$ ：尾数，取值为1 ~ 2 - ε 或 0 ~ 1 - ε 。</li>
<li>$E$ ：阶码，表示2的E次幂。</li>
</ul>
<p>对这三部分进行编码：</p>
<ul>
<li>一个单独的符号位直接编码 $s$ 。</li>
<li>$k$ 位阶码字段 $exp=e_{k-1} \dots e_1e_0$ 编码 $E$ 。</li>
<li>$n$ 位小数字段 $frac=f_{n-1} \dots f_1f_0$ 编码 $M$ 。</li>
</ul>
<p>以C语言为例，各部分编码位数如图1</p>
<center><img src="/2020/11/07/CSAPP-02-Floating-Point/1.png" width="75%"></center>

<center>图1 C语言浮点数编码位数</center>

<p>给定位表示，根据 $exp$ 的值，被编码的值可被分为三种情况，见图2（以单精度为例）</p>
<center><img src="/2020/11/07/CSAPP-02-Floating-Point/2.png" width="75%"></center>

<center>图2 单精度浮点数分类</center>

<ol>
<li><p><strong>规格化的</strong></p>
<p>阶码 $E=e-bias$ ，其中 $e=e_{k-1} \dots e_1e_0$ 是无符号数，$bias$ 是一个等于 $2^{k-1}-1$ 的偏置值（单精度即127），因此产生的指数范围是 -126 ~ 127。</p>
<p>尾数 $M=1+f$。</p>
</li>
<li><p><strong>非规格化的</strong></p>
<p>阶码 $E=1-bias$ ，尾数 $M=f$，此时尾数不包含隐含的1。非规格化数提供了浮点0的表示方法。</p>
</li>
<li><p><strong>特殊值</strong></p>
<p>当小数域全为0时，得到的值表示 $\infty$，根据符号位确定表示的是 $+\infty$ 还是 $-\infty$。</p>
<p>当小数域含有1时，得到的值表示 NaN，例如求 $\sqrt{-1}$ 就会得到这样的值。</p>
</li>
</ol>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>当某个数 $x$ 无法用给定精度位数表示需要进行，为其找到一个最近的，能进行浮点表示的数代表它，这就是舍入运算。</p>
<p>舍入运算会遇到的一个问题是究竟应该向下舍入还是向上舍入，一种方法是同时计算上下界 $x^+$ 和 $x^-$，使得 $x^- \le x \le x^+$。</p>
<p>IEEE浮点格式定义了四种不同的舍入方式</p>
<ol>
<li><strong>向偶数舍入：</strong> 4 舍，6 入，5 向偶数。例如 1.5 和 2.5 均舍为 2，3.5 和 4.5 均舍为 4。</li>
<li><strong>向零舍入：</strong> 正数下舍，负数上舍。</li>
<li><strong>向上舍入：</strong> ceil</li>
<li><strong>向下舍入：</strong> floor</li>
</ol>
<p>向偶数舍入可以降低平均值计算时的误差，用于找到最接近的匹配。其他三种方法用于计算上下界。</p>
<p>对于向偶数舍入，在具体操作时，当最低精度位为0时视为偶数，为1时视为奇数。每次舍入都倾向于使得最低精度位变为0。</p>
<p>例如当最低精度位为四分之一位，即小数点后两位时，$10.11100_2(2 \frac{7}{8})$ 被舍入到 $11.00_2(3)$。而 $10.10100_2(2 \frac{5}{8})$ 被舍入到 $10.10_2(2 \frac{1}{2})$。</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>谨慎地对浮点运算使用<strong>结合律</strong>和<strong>分配律</strong>，尤其是在出现大数运算时。例如如下的程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a1 = (<span class="number">3.14</span> + <span class="number">1e20</span>) - <span class="number">1e20</span>, a2 = <span class="number">3.14</span> + (<span class="number">1e20</span> - <span class="number">1e20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f %f\n%f %f\n&quot;</span>, a1, a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0.000000 3.140000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 03 - Machine-Level Programming</title>
    <url>/2021/02/05/CSAPP-03-Machine-Level-Programming/</url>
    <content><![CDATA[<p>Notes for Machine-Level Programming.</p>
<a id="more"></a>
<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="计算机设计"><a href="#计算机设计" class="headerlink" title="计算机设计"></a>计算机设计</h3><ul>
<li><p><strong>指令集架构（ISA）</strong></p>
<p>为编写机器/汇编代码而需要理解的处理器设计部分<br>如：指令集规范、寄存器</p>
<blockquote>
<p>Intel: x86, IA32, Itanium, x86-64<br>ARM: 广泛应用于移动设备<br>RISC V: 一种全新的开源ISA</p>
</blockquote>
</li>
<li><p><strong>微架构</strong></p>
<p>指令集架构的具体实现<br>如：缓存的大小、核心频率</p>
</li>
</ul>
<h3 id="汇编-机器代码"><a href="#汇编-机器代码" class="headerlink" title="汇编/机器代码"></a>汇编/机器代码</h3><ul>
<li><p><strong>CPU计算模型</strong></p>
<center><img src="/2021/02/05/CSAPP-03-Machine-Level-Programming/1.png" width="80%"></center>
</li>
<li><p><strong>汇编：数据类型</strong></p>
<ul>
<li>1、2、4、8字节的整数（作为数值或地址）</li>
<li>4、8、10字节的浮点数</li>
<li>代码：一系列指令构成的字节序列</li>
<li>没有复合类型如数组、结构体</li>
</ul>
<center><img src="/2021/02/05/CSAPP-03-Machine-Level-Programming/2.png" width="80%"></center>

<center>x86-64寄存器</center>

<center><img src="/2021/02/05/CSAPP-03-Machine-Level-Programming/3.png" width="80%"></center>

<center>IA32寄存器</center>
</li>
<li><p><strong>汇编：操作</strong></p>
<ul>
<li>在寄存器与内存间转移数据（双向）</li>
<li>在寄存器或内存数据上执行算术操作</li>
<li>转移控制（无条件跳转进入过程、条件分支、间接分支）</li>
<li>简单内存地址模式<br><em>mov_ src dest</em><br>movq、movl、movw、movb分别操作8、4、2、1个字节<br>(R): Mem[Reg[R]], movq (%rcx), %rax<br>D(R): Mem[Reg[R]+D], movq 8(%rcx), %rax</li>
<li>完全内存地址模式<br><em>lea_ src dest</em><br>leaq、leal、leaw、leab分别操作8、4、2、1个字节<br>D(Rb,Ri,S): Mem[Reg[Rb]+S*Reg[Ri]+D], leaq 8(%rdi,%rdi,2), %rax</li>
<li>其他指令<center><img src="/2021/02/05/CSAPP-03-Machine-Level-Programming/4.png" width="60%"></center>

</li>
</ul>
</li>
</ul>
<h3 id="C-gt-汇编码-gt-机器码"><a href="#C-gt-汇编码-gt-机器码" class="headerlink" title="C -&gt; 汇编码 -&gt; 机器码"></a>C -&gt; 汇编码 -&gt; 机器码</h3><center><img src="/2021/02/05/CSAPP-03-Machine-Level-Programming/5.png" width="80%"></center>]]></content>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>INT_MAX和INT_MIN</title>
    <url>/2020/04/03/INT-MAX%E5%92%8CINT-MIN/</url>
    <content><![CDATA[<p>今天Leetcode的每日一题是实现一个atoi函数，其中要求当参数大于INT_MAX或小于INT_MIN时返回INT_MAX或INT_MIN。做题时突然发现自己对如何通过位运算得到INT_MAX和INT_MIN还一知半解，因此决定探索一下。</p>
<a id="more"></a>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li><p><strong>int在C/C++中的字节数</strong></p>
<p>int具体所占的字节数和平台有关，标准的说法是不短于short，不长于long。在目前使用的大部分平台中通常都是4个字节，即32位。因此本文按32位分析。</p>
</li>
<li><p><strong>原码</strong></p>
<p>最高位是符号位，0表示正，1表示负，其他位是数字的绝对值的二进制。</p>
<p>例如：</p>
<p>1 的原码：00000000 00000000 00000000 00000001</p>
<p>-1 的原码：10000000 00000000 00000000 00000001</p>
</li>
<li><p><strong>反码</strong></p>
<p>正数的反码与原码一致，负数的反码在原码的基础上保持符号位不变，其他位按位取反。</p>
<p>例如：</p>
<p>-1 的反码：11111111 11111111 11111111 11111110</p>
</li>
<li><p><strong>补码</strong></p>
<p>正数的补码与原码一致，负数的补码是其<strong>反码加1</strong>。</p>
<p>例如：</p>
<p>-1 的补码：11111111 11111111 11111111 11111111</p>
</li>
</ul>
<h3 id="INT-MAX和INT-MIN的值"><a href="#INT-MAX和INT-MIN的值" class="headerlink" title="INT_MAX和INT_MIN的值"></a>INT_MAX和INT_MIN的值</h3><p>计算机中的数字都使用补码表示，原因是为了“化减为加”，只需要实现一个加法器就可以同时完成加和减两种运算。int是带符号整数，只有31位可以表示数字，因此就可以得到</p>
<p><strong>INT_MAX：</strong> 01111111 11111111 11111111 11111111，即 $2^{31}-1$</p>
<p><strong>INT_MIN：</strong> 10000000 00000000 00000000 00000000，即 $-2^{31}$</p>
<p>以上均为补码表示，注意到INT_MIN的原码和补码是一致的，且从原码的定义看，INT_MIN应该表示“负0”才对，但由于我们不需要两个0，因此人为规定补码10000000 00000000 00000000 00000000表示 $-2^{31}$。</p>
<p>同时根据补码的运算规则可以发现的一个规律是：</p>
<script type="math/tex; mode=display">
INT\_MAX = INT\_MIN-1</script><p>同理：</p>
<script type="math/tex; mode=display">
INT\_MIN = INT\_MAX+1</script><h3 id="INT-MAX和INT-MIN的获得"><a href="#INT-MAX和INT-MIN的获得" class="headerlink" title="INT_MAX和INT_MIN的获得"></a>INT_MAX和INT_MIN的获得</h3><p>有了上面的分析，就可以定义INT_MAX和INT_MIN了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：16进制硬编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：利用无符号整型和公式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = ((<span class="keyword">unsigned</span>)(<span class="number">-1</span>)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = INT_MAX + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：climits/limitis.h头文件中已定义，可直接使用</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Java笔记-（1）面向对象</title>
    <url>/2020/09/30/Java%E7%AC%94%E8%AE%B0-%EF%BC%881%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Java面向对象的一些关键知识</p>
<a id="more"></a>
<h3 id="面向对象的四个特征"><a href="#面向对象的四个特征" class="headerlink" title="面向对象的四个特征"></a>面向对象的四个特征</h3><ul>
<li><strong>抽象：</strong> 提取出一类事物的共有属性和行为。</li>
<li><strong>封装：</strong> 把抽象出的数据和行为封装在一起，供程序其他部分有权限地使用。</li>
<li><strong>继承：</strong> 在已有结果基础上继续进行功能的扩充</li>
<li><strong>多态：</strong> 同一类型的同一行为在不同情况下可以表现出不同的状态。</li>
</ul>
<h3 id="权限关键字"><a href="#权限关键字" class="headerlink" title="权限关键字"></a>权限关键字</h3><div class="table-container">
<table>
<thead>
<tr>
<th>访问权限</th>
<th>本类</th>
<th>本包的类</th>
<th>子类</th>
<th>非子类的外包类</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>public</strong></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><strong>private</strong></td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>方法名与类名相同，没有返回值类型</li>
<li>用于初始化对象属性</li>
<li>在使用new语句时被调用</li>
<li>不显示声明时，在编译时会为类自动加上一个无参的空构造方法</li>
<li>可通过重载实现多个接受不同参数的构造方法</li>
<li>显示声明时，将不再自动添加无参空构造方法</li>
<li>可在构造方法中使用 <code>this(...)</code> 调用其他构造方法，且该语句应放在方法的第一行。</li>
<li>保留无参空构造方法是一个好习惯（某些框架可依其通过反射创建对象）</li>
<li>private修饰的构造方法可用于实现单例模式</li>
</ul>
<h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p><strong>Java中只存在值传递</strong>。Java中包含两类数据类型：</p>
<ol>
<li><strong>基本类型</strong><ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>char</li>
<li>boolean</li>
</ul>
</li>
<li><strong>引用类型，其值表示一个地址</strong><ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>Java中的继承是单继承</li>
<li>子类可以拥有父类非private的成员</li>
<li>子类可以定义自己的成员，对父类进行扩展</li>
<li>子类可以<strong>重写</strong>父类的方法（多态的实现）</li>
<li>子类不能继承父类的构造方法，但可以通过 <code>super(...)</code> 调用父类的构造方法</li>
<li>子类会调用父类的默认构造方法，但若默认构造方法不存在，则必须显式地通过 <code>super</code> 调用父类的构造方法，且该语句必须位于子类构造方法的第一行</li>
</ul>
<h3 id="对象初始化顺序"><a href="#对象初始化顺序" class="headerlink" title="对象初始化顺序"></a>对象初始化顺序</h3><ol>
<li>父类静态字段初始化、父类静态代码块（取决于二者声明的先后顺序）</li>
<li>子类静态字段初始化、子类静态代码块（取决于二者声明的先后顺序）</li>
<li>父类普通字段初始化</li>
<li>父类构造代码块</li>
<li>父类构造方法</li>
<li>子类普通字段初始化</li>
<li>子类构造代码块</li>
<li>子类构造方法</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>定义类时使用abstract修饰</li>
<li>抽象类可以有构造方法、属性、方法实现</li>
<li>抽象类可以没有抽象方法，但存在抽象的方法一定要定义为抽象类</li>
<li>非抽象类继承抽象类时需要实现所有抽象方法</li>
<li>抽象类继承抽象类时可以不实现父类抽象方法</li>
<li>抽象类不能被实例化</li>
<li>抽象类不能用final修饰</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>使用interface定义</li>
<li>接口可以继承其他<strong>多个</strong>接口</li>
<li>类可以实现<strong>多个</strong>接口</li>
<li>抽象类实现接口时可以不实现接口的方法</li>
<li>接口不能有构造方法</li>
<li>接口不能被实例化</li>
<li><p>接口中可以定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实际为 public static final int CONSTANT = 10;</span></span><br><span class="line">  <span class="keyword">int</span> CONSTANT = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实际为 public abstract void abstractMethod();</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Default Implementation&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Static Method&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>常量</strong></p>
<p>如CONSTANT的定义所示。<strong>可以被继承</strong>。接口中定义的所有属性默认用public static final修饰，这些关键字可以省略。当实现类中出现命名冲突时，可以使用 <code>Interface1.CONSTANT</code> 使用接口中的常量。</p>
</li>
<li><p><strong>抽象方法</strong></p>
<p>如abstractMethod的定义所示。接口中定义的无实现方法默认使用public abstract修饰，这些关键字可以省略。实现接口时需要重写接口中的所有抽象方法。</p>
</li>
<li><p><strong>默认实现方法（JDK 1.8及以后）</strong></p>
<p>如defaultMethod的定义所示。默认实现方法存在方法体，在实现接口时可以不重写这些方法。但若实现类实现了多个接口，且这些接口中存在同名的默认实现方法，实现类中就必须重写重名的默认实现方法。</p>
<p>默认实现方法必须通过接口的实现类来调用，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Interface1Impl().defaultMethod();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>静态方法（JDK1.8及以后）</strong></p>
<p>如staticMethod的定义所示。<strong>不可以被继承</strong>。接口中的静态方法必须通过接口名访问，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Interface1.staticMethod();</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3></li>
</ol>
</li>
<li><p><strong>成员内部类</strong></p>
<ul>
<li>定义为外部类的一个成员</li>
<li>成员内部类对象依赖外部类对象而存在，在创建成员内部类对象前需要先创建其外部类对象</li>
<li>成员内部类中使用 <code>this</code> 访问自身的属性和方法，使用 <code>外部类名.this</code> 访问其外部类中的属性和方法</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a1 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer: &quot;</span>+a1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a1;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            a1=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问外部类的属性</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.Outer: &quot;</span>+Outer.<span class="keyword">this</span>.a1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问自身的属性</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Inner: &quot;</span>+a1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在外部类中实例化内部类对象</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在外部类外部实例化内部类对象</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Outer: 10</span></span><br><span class="line"><span class="comment">Inner.Outer: 10</span></span><br><span class="line"><span class="comment">Inner: 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>静态内部类</strong></p>
<ul>
<li>如同类的其他静态成员，在没有外部类对象时，可以使用 <code>外部类名.内部类名</code> 来使用静态内部类</li>
<li>静态内部类中无法访问外部类的非静态成员</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a2 = <span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer: &quot;</span>+a2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            a2=<span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问外部类的静态属性</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.Outer: &quot;</span>+Outer.a2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问自身的属性</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Inner: &quot;</span>+a2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在外部类中实例化内部类对象</span></span><br><span class="line">        StaticInner inner = <span class="keyword">new</span> StaticInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在外部类外部实例化内部类对象</span></span><br><span class="line">        Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Outer: 11</span></span><br><span class="line"><span class="comment">Inner.Outer: 11</span></span><br><span class="line"><span class="comment">Inner: 111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>局部内部类</strong></p>
<ul>
<li>定义在外部类的<strong>方法/代码块</strong>中</li>
<li>局部内部类不能有静态成员</li>
<li>局部内部类中可以使用 <code>外部类名.this</code> 访问其外部类中的属性和方法，但外部类不能访问局部内部类中定义的成员</li>
<li>局部内部类只能在定义域内被实例化</li>
<li><p>JDK 1.8以前，局部内部类对象不能使用该内部类所在方法的非 <code>final</code> 局部变量</p>
<blockquote>
<p>当调用方法时，局部变量如果没有用final修饰，其生命周期和方法的生命周期是一样的。方法被调用时会入栈，方法结束后即弹栈，这个局部变量也会消失。那么如果局部内部类对象还没有马上消失想用这个局部变量，显然已无法使用了。用final修饰的变量会在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也就可以继续使用了。</p>
<p>JDK 1.8及以后编译器会自动为被局部内部类使用的局部变量加上final关键字修饰。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>匿名内部类</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">  <span class="comment">// 重写或定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>是局部内部类的延伸，所有局部内部类的限制都对其生效</li>
<li>一定跟在 <code>new</code> 后面</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态分为<strong>方法的重写与重载</strong>和<strong>对象的多态性</strong>两部分</li>
<li>父类引用可以指向子类对象，自动转换（向上转型）</li>
<li>子类引用指向父类对象时需要强制转换（向下转型）</li>
<li>实现多态的三个必要条件：<strong>继承、重写、向上转型</strong><ul>
<li><strong>继承：</strong> 在多态中需要存在有继承关系的父类和子类</li>
<li><strong>重写：</strong> 子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li><strong>向上转型：</strong> 父类的引用指向父类对象时，调用的是父类中定义的方法；指向子类对象时，调用的是子类中定义的方法。</li>
</ul>
</li>
<li>将接口的引用指向不同的实现该接口的类实例可以实现基于接口的多态</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li><p><strong>this</strong></p>
<ul>
<li>指向当前对象的引用</li>
<li>调用属性：<code>this.属性名</code> ，可用于解决成员变量名和局部变量名冲突</li>
<li>调用方法：<code>this.方法名(...)</code></li>
<li>调用构造方法：<code>this(...)</code> ，只能用于构造方法中，且作为方法的第一条语句</li>
</ul>
</li>
<li><p><strong>super</strong></p>
<ul>
<li>指向父类的引用</li>
<li>调用父类的属性：<code>super.属性名</code> ，可用于访问被子类隐藏的父类属性</li>
<li>调用父类的方法：<code>super.方法名(...)</code></li>
<li>调用父类的构造方法：<code>super(...)</code> ，若父类的默认构造方法不存在，则在子类构造方法中必须使用这种方法显式地调用父类的构造方法，且作为方法的第一条语句</li>
</ul>
</li>
<li><p><strong>static</strong></p>
<ul>
<li>可修饰属性、方法、代码块，表示当前修饰的成员为静态的</li>
<li>通过 <code>类名.属性名（或方法名）</code> 调用</li>
<li>静态属性、静态方法属于类，而不是对象</li>
<li>静态属性按照定义顺序初始化</li>
<li>静态方法内不可使用 <code>this</code> 和 <code>super</code> 关键字</li>
<li>静态方法内不可使用非静态成员，但非静态方法内部可以使用静态成员</li>
<li>静态代码块在类初次加载时被调用</li>
</ul>
</li>
<li><p><strong>final</strong></p>
<ul>
<li>修饰属性，表示声明一个常量</li>
<li>修饰方法，表示该方法无法被重写</li>
<li>修饰类，表示该类无法被继承</li>
<li>修饰方法参数，在方法内部不能修改参数的值</li>
</ul>
</li>
<li><p><strong>abstract</strong></p>
<ul>
<li>修饰类时表示该类为抽象类<br><em>细节见 &lt;抽象类&gt;</em></li>
<li>修饰方法时表示该方法为抽象方法<ol>
<li>只有声明，没有实现</li>
<li>抽象方法不能用private修饰，因为子类无法重写</li>
<li>抽象方法不能用static修饰</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>instanceof</strong></p>
<ul>
<li>用于检查对象是否为某个类的实例</li>
<li><p>通常在把父类引用强制转为子类引用时使用，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = ... ;<span class="comment">// 从某个方法中获得一个Object类型引用</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记-（2）Object类</title>
    <url>/2020/10/20/Java%E7%AC%94%E8%AE%B0-%EF%BC%882%EF%BC%89Object%E7%B1%BB/</url>
    <content><![CDATA[<p>Object类是Java中所有类的基类。定义的任何类都会默认继承Object类。Object类中有一系列重要的方法。</p>
<a id="more"></a>
<h3 id="1-getClass"><a href="#1-getClass" class="headerlink" title="1. getClass"></a>1. getClass</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>
<p>返回该对象运行时类的Class对象。Class对象记录了类的信息，包括属性、方法。被 <code>static synchronized</code> 修饰的方法锁住的即为该对象。</p>
<h3 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2. hashCode"></a>2. hashCode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回该对象的一个hash值，该方法支持着各类哈希表的实现，如 <code>HashMap</code> 。</p>
<p>Object对该方法的默认实现是将对象的内部地址转换为一个整形值。</p>
<p>该方法的重写约定包括：</p>
<ol>
<li>Java应用程序执行期间多次对同一个对象调用 <code>hashCode</code> 方法时，只要没有修改在对象 <code>equals</code> 方法比较中使用的信息，该方法就必须一致地返回相同的整数。但不要求同一应用程序在不同的执行中返回相同的值。</li>
<li>若根据 <code>equals(Object)</code> 方法得到两个对象相等，则两个对象的 <code>hashCode</code> 需要返回相同的值。</li>
<li>若根据 <code>equals(Object)</code> 方法得到两个对象相等，并不要求两个对象的 <code>hashCode</code> 一定要返回不同的值。但设计时最好降低二者 <code>hashCode</code> 返回相同值的概率，这样可以提高哈希表的性能。</li>
</ol>
<h3 id="3-equals"><a href="#3-equals" class="headerlink" title="3. equals"></a>3. equals</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回某个对象是否和当前对象“相等”。该方法实现了一个非空对象引用的等级关系。即</p>
<ol>
<li>自反性：对于任何非空引用 <code>x</code> ，<code>x.equals(x)</code> 始终为true</li>
<li>对称性：对于任何非空引用 <code>x</code> ，<code>x.equals(y)</code> 和 <code>y.equals(x)</code> 同真假</li>
<li>传递性：对于任何非空引用 <code>x</code> ，若 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 为true，则 <code>x.equals(z)</code> 为true</li>
<li>一致性：对于任何非空引用 <code>x</code> ，假设 <code>equals</code> 方法中用到的信息不被修改，则对 <code>x.equals(y)</code> 的多次调用应始终返回相同的值</li>
<li>对于任何非空引用 <code>x</code> ，<code>x.equals(null)</code> 应始终返回false</li>
</ol>
<h3 id="4-clone"><a href="#4-clone" class="headerlink" title="4. clone"></a>4. clone</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>
<p>返回当前对象的一个拷贝对象。若类未实现 <code>Clonealbe</code> 接口会抛出 <code>CloneNotSupportedException</code> ，否则返回当前对象的一个<strong>浅拷贝</strong>，即新建一个对象，并简单地将当前对象所有属性的值赋给新对象。此外，所有数组类型 <code>T[]</code> 默认实现了 <code>Clonealbe</code> 接口，无论 <code>T</code> 是基本类型还是引用类型。</p>
<h3 id="5-toString"><a href="#5-toString" class="headerlink" title="5. toString"></a>5. toString</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回当前对象的字符串表示。建议在所有子类中重写它。</p>
<h3 id="6-notify"><a href="#6-notify" class="headerlink" title="6. notify"></a>6. notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>唤醒等待该对象monitor的一个线程。若有多个线程在等待，则会选择其中一个。选择是任意的，由实现自行决定。</p>
<p>在当前线程释放该对象的monitor之前，被唤醒的线程将无法继续执行。</p>
<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）</strong></p>
<p>一个线程可以通过三种方式获取对象的monitor。</p>
<ol>
<li>通过执行一个对象的由 <code>synchronized</code> 修饰的实例方法</li>
<li>通过执行被 <code>synchronized</code> 修饰的代码块，且 <code>synchronized</code> 锁住的是当前对象</li>
<li>对于Class类对象，通过执行该类被  <code>static synchronized</code> 修饰的方法</li>
</ol>
<p>一个对象的monitor在一个时刻只能被一个线程持有。</p>
<h3 id="7-notifyAll"><a href="#7-notifyAll" class="headerlink" title="7. notifyAll"></a>7. notifyAll</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>唤醒所有等待该对象monitor的线程。</p>
<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）</strong></p>
<h3 id="8-wait"><a href="#8-wait" class="headerlink" title="8. wait"></a>8. wait</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeoutMillis value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span> &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) &#123;</span><br><span class="line">        timeoutMillis++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wait(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使当前对象所在的线程进入等待状态，直到其他线程调用该对象的 <code>notify</code> 或 <code>notifyAll</code> 方法，或等待指定的时间。</p>
<p><strong>调用该方法的线程必须持有当前对象的monitor（🔒）。</strong></p>
<p>该方法会使当前线程将自身加入对象的等待集，然后放弃此对象上的任何同步声明。在以下四种情况发生前，当前线程将保持休眠，不参与线程调度。</p>
<ol>
<li>其他线程调用对象的 <code>notify</code> 方法且当前线程正好被选中唤醒</li>
<li>其他线程调用对象的 <code>notifyAll</code> 的方法</li>
<li>其他线程调用当前线程的 <code>interrupt</code> 方法</li>
<li>经过指定的等待时间。若指定时间为0，则表示等待无限长时间，只能被其他三种方法唤醒。</li>
</ol>
<p>达到触发条件后，当前线程将从对象的等待集中移除，并重新参与线程调度以及和其他线程对<strong>该对象</strong>的竞争。</p>
<p>注意，当wait方法将当前线程放入该对象的等待集时，它只解锁该对象。在线程等待时，当前线程上可能被同步的任何其他对象将保持锁定。</p>
<h3 id="9-finalize"><a href="#9-finalize" class="headerlink" title="9. finalize"></a>9. finalize</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>当垃圾收集确定没有对对象的更多引用时，由垃圾收集器在对象上调用。子类可以重写finalize方法来释放系统资源或执行其他清理。</p>
<p><code>finalize</code> 方法中可以采取任何措施，包括使该对象再次对其他线程可用。但通常情况下，<code>finalize</code> 方法的作用是在该对象被无法恢复地销毁前执行一些清除操作，例如释放一些非Java资源（打开的文件、数据库连接）或调用非Java方法时分配的内存（C的malloc）。由于GC的不确定性，<code>finalize</code> 的调用时机也是不确定的。即，从一个对象变得不可达，到其 <code>finalize</code> 方法被调用，这期间经历的时间不确定，因此不要过于依赖 <code>finalize</code> 来完成资源回收，很可能在 <code>finalize</code> 被调用前资源就已耗尽。最好的方法是当不再需要分配给对象的资源时，在业务代码中就进行释放操作。</p>
<p>Java不能保证由哪个线程来调用给定对象的 <code>finalize</code> 方法。但可以保证的是，在调用 <code>finalize</code> 时，调用线程将不持有任何用户可见的同步锁。如果 <code>finalize</code> 方法抛出未捕获的异常，则该异常将被忽略，并且该对象的终结将终止。</p>
<p><strong><code>finalize</code> 方法最多只会被调用一次。</strong></p>
<p>Object对象的 <code>finalize</code> 方法不执行任何特殊操作，它只是正常返回。Object的子类可以重写该方法。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU和LFU</title>
    <url>/2020/04/06/LRU%E5%92%8CLFU/</url>
    <content><![CDATA[<h2 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h2><p>缓存是为了解决存储介质间读写速度相差过大而设置的一块大小有限的数据缓存区。经由缓存中转，可极大地提高数据的读写速度，从而提高系统性能。由于缓存大小有限，当存储的数据达到其大小限制时就需要淘汰掉其中一部分“价值最小”的数据，从而使其可以装入新的数据。这就是<strong>缓存淘汰算法</strong>的工作。缓存淘汰算法在计算机科学中应用十分广泛，从最底层的硬件到最上层的应用层都有着它的身影。例如缓和CPU和内存间速度差异的Cache，操作系统层的虚拟内存，应用层的缓存中间件等等。不同的评判数据价值的方式催生了不同的缓存淘汰算法，常见的有FIFO、LRU、LFU等。本次，我们结合两道题目分析LRU和LFU两种缓存淘汰算法。</p>
<a id="more"></a>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>LRU的全称是<strong>Least Recently Used</strong>，即最近最少使用。该算法认为最近最少使用的数据块是“最没有价值的”，因此在每次缓存满时淘汰它。</p>
<p>举个例子，当缓存容量为3，数据序列为 2 1 2 1 2 3 4 时，被淘汰的数据是1。</p>
<h3 id="Leetcode-146-LRU缓存机制"><a href="#Leetcode-146-LRU缓存机制" class="headerlink" title="Leetcode 146-LRU缓存机制"></a>Leetcode 146-LRU缓存机制</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p><strong>进阶：</strong></p>
<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>利用<strong>双向链表+哈希表</strong>实现。维护一个由value节点链成的双向链表和一个从key到value节点的哈希表。</p>
<ul>
<li><p><strong>get</strong></p>
<p>首先检查哈希表，看key是否存在，若不存在直接返回-1。若存在，将当前value节点从链表中删除，再插入到链表头，最后返回value。</p>
</li>
<li><p><strong>put</strong></p>
<p>首先直接调用get方法检查哈希表，看key是否已存在。若存在，经过get方法，value节点已经到达表头，只需要更新value的值即可。若不存在，则需要在链表中插入新节点。插入前需要先检查链表中的元素数是否已经等于capacity。若是，链表尾元素就是最近最少使用的元素，淘汰即可。之后再将新节点插入到链表头。最后将映射关系加入哈希表。</p>
</li>
</ul>
<p>get和put的时间复杂度均为 <script type="math/tex">O(1)</script> 。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node pre;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node cur = hash.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node pre = cur.pre, next = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123; <span class="comment">// 说明cur不为head，将其放于head</span></span><br><span class="line">            pre.next = next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>)</span><br><span class="line">                next.pre = pre;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tail = pre;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head.pre = cur;</span><br><span class="line">            cur.pre = <span class="keyword">null</span>;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.get(key) != -<span class="number">1</span>) &#123;</span><br><span class="line">            hash.get(key).value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="comment">// 新节点都插入为head</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            head = tail = cur;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head.pre = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash.size() == capacity) &#123; <span class="comment">//若已达容量删除tail</span></span><br><span class="line">            hash.remove(tail.key);</span><br><span class="line">            tail = tail.pre;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash.put(key, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>LFU的全称是<strong>Least Frequently Used</strong>，即最不常使用。该算法在选择淘汰的数据块时以其使用次数为依据，使用次数最少的将被淘汰。</p>
<p>还是使用LRU的例子，缓存容量为3，数据序列为 2 1 2 1 2 3 4 ，LFU中被淘汰的数据是3。</p>
<h3 id="Leetcode-460-LFU缓存"><a href="#Leetcode-460-LFU缓存" class="headerlink" title="Leetcode 460-LFU缓存"></a>Leetcode 460-LFU缓存</h3><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。</p>
<p>get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。<br>put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。</p>
<p><strong>进阶：</strong><br>你是否可以在 <strong>O(1)</strong> 时间复杂度内执行两项操作？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LFUCache cache &#x3D; new LFUCache( 2 &#x2F;* capacity (缓存容量) *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 去除 key 2</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到key 2)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 去除 key 1</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到 key 1)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回 3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>采用和LRU相似的思路，我们希望在淘汰操作时所有节点也可以按淘汰顺序形成一个列表，待淘汰的元素位于表头。LFU中根据使用频率来决定淘汰的节点，每次淘汰使用频率最少的那个。当多个节点频率值相同时，再采用LRU来淘汰节点。因此，最终我们需要的列表应该是这样的：使用频率从头到尾依次增大，使用频率相等时，使用时间戳从头到尾依次增大。这样一个序列我们可以通过一颗<strong>平衡二叉树</strong>实现，在Java中，使用TreeSet即可。此外，为了获取到value节点，仍然需要一个<strong>哈希表</strong>。</p>
<ul>
<li><p><strong>get</strong></p>
<p>首先检查哈希表，看key是否存在，若不存在直接返回-1。若存在，先将value节点从TreeSet中移除，更新其使用频率和时间戳，再将其重新插入TreeSet中，最后返回value。</p>
</li>
<li><p><strong>put</strong></p>
<p>首先直接调用get方法检查哈希表，看key是否已存在。若存在，经过get方法，value节点已经到达树中的新位置，只需要更新value的值即可。若不存在，则需要在链表中插入新节点。插入前需要先检查TreeSet中的元素数是否已经等于capacity。若是，树中最左端的元素就是需要淘汰的元素。可调用pollFirst方法获取。之后再将新节点插入到TreeSet中。最后将映射关系加入哈希表。</p>
</li>
</ul>
<p>由于get和put操作中都需要对平衡二叉树进行插入删除操作，因此二者的最终时间复杂度均为 <script type="math/tex">O(lgn)</script>。还可以使用双链表实现真正的 <script type="math/tex">O(1)</script> 。（有机会再补</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> freq;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.value = v;</span><br><span class="line">            <span class="keyword">this</span>.time = t;</span><br><span class="line">            <span class="keyword">this</span>.freq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.freq &lt; n.freq)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.freq &gt; n.freq)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.time &lt; n.time)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.time &gt; n.time)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;Node&gt; tree;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; hash;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Node cur = hash.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        tree.remove(cur);</span><br><span class="line">        cur.freq++;</span><br><span class="line">        cur.time = ++time;</span><br><span class="line">        tree.add(cur);</span><br><span class="line">        <span class="keyword">return</span> cur.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.get(key) != -<span class="number">1</span>) &#123;</span><br><span class="line">            hash.get(key).value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree.size() == capacity) &#123; <span class="comment">//若已达容量删除TreeSet中首个元素</span></span><br><span class="line">            Node drop = (Node) tree.pollFirst();</span><br><span class="line">            hash.remove(drop.key);</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(key, value, ++time);</span><br><span class="line">        tree.add(cur);</span><br><span class="line">        hash.put(key, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 3-无重复字符的最长子串</title>
    <url>/2020/03/18/Leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>面试栽在了这道题上，当时糊涂了没想明白，决定重做一遍。</p>
<p>采用双指针，$i$ 和 $j$ 分别指向当前判断的子串的首尾。用<code>map&lt;char,int&gt;</code>保存字符上一次出现的位置+1，+1的原因是为了避免和map中当key不存在时，int默认值为0的情况冲突。同时维护遍历过程中的最大长度。</p>
<p>初始化 $i=0, j=1$，每次判断 $s[j]$ 在map中的值，会存在三种情况：</p>
<ol>
<li><p>$m[s[j]] = 0$：</p>
<p>表示 $s[j]$ 尚未在 $s[0, j)$ 中出现过。</p>
</li>
<li><p>$m[s[j]] - 1 &lt; i$：</p>
<p>表示 $s[j]$ 在 $s[0, i)$ 中出现过，但没有在 $s[i,j)$ 中出现过。</p>
</li>
<li><p>$m[s[j]] - 1 \ge i$：</p>
<p>表示 $s[j]$ 在 $s[i,j)$ 中出现过。</p>
</li>
</ol>
<p>在第1、2种情况中， $s[j]$ 并没有出现在当前判断的子串内，因此可以被加入到子串中，同时判断最大长度是否可更新。</p>
<p>在第3种情况中，$s[j]$ 出现在了当前判断的子串内，设其位置为 $j’$ ，此时可直接使指针 $i=j’+1$，即令 $i=m[s[j]]$。因为当 $i$ 取 $[i, j’]$ 中任何值时，$s[i,j]$ 中都将存在重复字符。</p>
<p>无论上述哪一种情况，在判断完 $s[j]$ 后，都应更新使 $m[s[j]]=j+1$ ，同时使 $j$ 右移一位。循环上述过程直到 $j$ 遍历完 $s$ ，此时维护的最大长度即为答案，算法复杂度 $O(n)$。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, e;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; pos;<span class="comment">//pos[ch]表示ch在str中出现的位置+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        pos[str[s]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (e = <span class="number">1</span>; e &lt; str.length(); e++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos[str[e]] - <span class="number">1</span> &gt;= s) </span><br><span class="line">                s = pos[str[e]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans = max(e-s+<span class="number">1</span>, ans);</span><br><span class="line">            pos[str[e]] = e + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 406-根据身高重建队列</title>
    <url>/2021/02/06/Leetcode-406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>
<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们需要对完全无序的队列做一些预处理。考虑这样一个排队问题：</p>
<p>有 $n$ 个人，将他们从高到矮排成一队，设排队每个位置上的身高分别是 $h_0,h1,\cdots ,h_{n-1}$ 。</p>
<p>若 $n$ 个人的身高不同，该问题十分简单。但若存在身高相同的人时，我们需要指定一个特殊的排序方式才能排出一个完整的队列。我们可以利用原问题提供的 $k$ 值。设 $h_i=h_j, k_i&gt;k_j$ 。显然，原问题中，身高相同时，$k$ 值越大的人所在位置越靠后，即 $h_i$ 必然会排在 $h_j$ 之后。因此可以设 $h_i = h_j - \delta$ ，其中 $\delta$ 是一个不影响其他身高排序的微小量。这样一来，每个人的身高又可以视为不同的了。</p>
<p>解决这一问题只需要对原序列做这样一个排序：<strong>首先按第一分量（身高）降序排列，当第一分量相等时，按第二分量（k）升序排列</strong>。</p>
<p>在完成这一排序后，我们再考虑原问题。原问题要求，对于队伍中位置 $i$ 的人，队伍之前身高 $\ge h_i$ 的人数正好为 $k_i$。我们将上一问题排好的顺序重新排入下一个队列。当排入第 $i$ 个人时：</p>
<ul>
<li>第 $0, \cdots , i-1$ 个人已经在队伍中安排好了位置。他们都比第 $i$ 个人高，因此，只要他们排在第 $i$ 个人前面即可对 $k_i$ 产生影响。</li>
<li>第 $i+1, \cdots, n-1$ 个人都比第 $i$ 个人矮，无论他们站在哪里都不会对第 $i$ 个人产生影响。</li>
</ul>
<p>因此，我们只要将第 $i$ 个人“插入”当前以排好的队伍，使得其前面正好有 $k_i$ 个人即可。依次处理每一个人，即可得到原问题需要的排序。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            ans.add(person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 60-第k个排列</title>
    <url>/2020/09/10/Leetcode-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出集合 <code>[1,2,3,…,n]</code>，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>给定 n 和 k，返回第 k 个排列。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3, k &#x3D; 3</span><br><span class="line">输出: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 9</span><br><span class="line">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p><strong>全排列算法（笨笨）</strong></p>
<p>给定一个排列a，题中生成下一个排列b的方法实际上是寻找一个使得a增加值最小的排列，该排列即为排列b。</p>
<p>其算法描述如下：</p>
<ol>
<li>从右到左扫描当前排列，寻找第一个相邻递减数字。递减的数字称为<strong>Partition Number</strong>。</li>
<li>从右到左扫描当前排列，寻找第一个比<strong>Partition Number</strong>大的数字。称其为<strong>Change Number</strong>。</li>
<li>交换<strong>Partition Number</strong>和<strong>Change Number</strong>。</li>
<li>逆向<strong>Partition Number</strong>所在位置右边的所有数字。</li>
</ol>
<p>完成以上四步操作即可得到使得排列a增加值最少的排列b。</p>
<p>根据题中的描述，只需要对排列 <code>12...n</code> 执行 k-1 次该算法即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nextPermutation</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左扫描第一个相邻递减数字，即Partition Number</span></span><br><span class="line">        <span class="keyword">int</span> len = v.length(), pn = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (v.charAt(i) &lt; v.charAt(i + <span class="number">1</span>))&#123;</span><br><span class="line">                pn = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pn == len) <span class="comment">// 到达最后一个排列返回自身</span></span><br><span class="line">            <span class="keyword">return</span> v.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左寻找第一个比Partition Number大的数字，称之为Change Number</span></span><br><span class="line">        <span class="keyword">int</span> cn = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; pn; i--)</span><br><span class="line">            <span class="keyword">if</span> (v.charAt(i) &gt; v.charAt(pn)) &#123;</span><br><span class="line">                cn = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换PN和CN</span></span><br><span class="line">        <span class="keyword">char</span> tmp = sb.charAt(pn);</span><br><span class="line">        sb.setCharAt(pn, sb.charAt(cn));</span><br><span class="line">        sb.setCharAt(cn, tmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逆向PN右侧的数，得到结果</span></span><br><span class="line">        String s = sb.substring(pn + <span class="number">1</span>);</span><br><span class="line">        sb.delete(pn + <span class="number">1</span>, len);</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        sb.append(sb2.reverse().toString());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sb.append(i);</span><br><span class="line">        </span><br><span class="line">        String ans = sb.toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">            ans = nextPermutation(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 77-组合</title>
    <url>/2020/03/16/Leetcode-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个整数 $n$ 和 $k$，返回 $1\cdots n$ 中所有可能的 $k$ 个数的组合。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p><strong>DFS + 回溯</strong></p>
<p>搜索起点为 $1\cdots n - k + 1$，控制搜索树最大深度为 $k$，树中值为 $i$ 的子节点为 $[i+1, n]$。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        v.push_back(cur);</span><br><span class="line">        <span class="keyword">if</span> (v.size() == k) &#123;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dfs(ans, v, n, k, i);</span><br><span class="line">                v.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cbs;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            dfs(ans, cbs, n, k, i);</span><br><span class="line">            cbs.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>利用公式</strong> $C_n^k=C_{n-1}^k+C_{n-1}^{k-1}$</p>
<p>从 $1\cdots n$ 中选 $k$ 个数只包含两种情况：</p>
<ol>
<li>这 $k$ 个数中包含 $n$ ，还需从剩下 $n-1$ 个数中选出 $k-1$ 个，方案数为 $C_{n-1}^{k-1}$ 。</li>
<li>这 $k$ 个数中不包含 $n$ ，还需从剩下 $n-1$ 个数中选出 $k$ 个，方案数为 $C_{n-1}^k$。</li>
</ol>
<p>因此可递归求解，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cbs;</span><br><span class="line">                cbs.push_back(i);</span><br><span class="line">                ans.push_back(cbs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cbs;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                cbs.push_back(i);</span><br><span class="line">            ans.push_back(cbs);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = combine(n - <span class="number">1</span>, k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tmp = combine(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">            tmp[i].push_back(n);</span><br><span class="line">            ans.push_back(tmp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 面试题17.16-按摩师</title>
    <url>/2020/03/24/Leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9817-16-%E6%8C%89%E6%91%A9%E5%B8%88/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义 $dp[i]$ 表示以 $i$ 号预约结尾时的最大服务时长。</p>
<p>首先注意到一定存在 $dp[i] \ge dp[i-2]$ ，因为若 $dp[i]$ 中选择 $i-2$ 号预约时，将有 $dp[i]=dp[i-2]+nums[i]$ 。</p>
<p>此外，当选择了 $i$ 号预约后，$i-1$ 号预约将无法被选择，根据上面结论，$dp[i-2] \ge dp[i-4]$， $dp[i-3] \ge dp[i-5]$，因此状态转移方程为：</p>
<script type="math/tex; mode=display">
dp[i]=max(dp[i-2]+dp[i-3])+nums[i]</script><p>注意边界条件，$dp[0]=0$，$dp[i] = nums[i]\space(i \le 2)$。</p>
<p>最终的答案为 $max(dp[n], dp[n-1])$ ，其中 $n$ 为序列长度。因为整个序列的最大服务时长序列中要么包括 $n$ 号预约，要么不包括。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = max(dp[i - <span class="number">2</span>], dp[i - <span class="number">3</span>]) + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处时间复杂度和空间复杂度均为 $O(n)$ ，由于我们只需要 $dp[n]$ 和 $dp[n-1]$ ，且每个状态的计算最多只涉及到前3项，因此可以用变量代替数组，空间复杂度降低为 $O(1)$ 。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Scientifically Surfing the Internet</title>
    <url>/2020/03/13/Scientifically-Surfing-the-Internet/</url>
    <content><![CDATA[<p>一个不可告人的秘密</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><p><strong>购买</strong></p>
<p>Vultr选购VPS，OS选择<strong>Ubuntu 18.04</strong>，该版本已支持BBR，无需更新内核</p>
<p>下方选择<strong>Enable IPv6</strong>，方便在某些时候IPv4被墙时利用IPv6转发</p>
<p>SSH Keys中放上本机的公钥</p>
<p>Hostname&amp;Label设置的是示例的名称</p>
</li>
<li><p><strong>测试</strong></p>
<p>ping一下国内的地址，看本VPS的IP是否被墙，被墙了需要换</p>
<p>在配置完成后也可以利用Win端SS客户端的日志来测试</p>
</li>
</ul>
<h2 id="ShadowSocks安装"><a href="#ShadowSocks安装" class="headerlink" title="ShadowSocks安装"></a>ShadowSocks安装</h2><h4 id="更新apt"><a href="#更新apt" class="headerlink" title="更新apt"></a>更新apt</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h4 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>
<h4 id="安装setuptools"><a href="#安装setuptools" class="headerlink" title="安装setuptools"></a>安装setuptools</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install setuptools</span><br></pre></td></tr></table></figure>
<h4 id="从github安装SS"><a href="#从github安装SS" class="headerlink" title="从github安装SS"></a>从github安装SS</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure>
<p>可以用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver --version</span><br></pre></td></tr></table></figure>
<p>查看SS的版本号，当前显示的是3.0.0</p>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>创建Shadowsocks配置文件所在文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure>
<p>在本机编辑好配置文件<strong>config.json</strong>，内容如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;45.77.181.212&quot;</span>,<span class="comment">//当前主机IP</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span>:<span class="number">8388</span>,<span class="comment">//端口</span></span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;password&quot;</span>,<span class="comment">//密码</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后将其放入 <strong>/etc/shadowsocks</strong> 目录下</p>
<h2 id="测试Shadowsocks配置"><a href="#测试Shadowsocks配置" class="headerlink" title="测试Shadowsocks配置"></a>测试Shadowsocks配置</h2><h4 id="启用配置文件"><a href="#启用配置文件" class="headerlink" title="启用配置文件"></a>启用配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>
<p>之后在客户端填写<strong>服务器地址、密码、端口</strong>，就可以测试了。可以尝试打开Google，如果能正常打开则本次抽到的IP大概率没问题</p>
<p>同时，在客户端开启全局模式的前提下，可以打开<strong><a href="http://ip138.com/">http://ip138.com/</a></strong>，查看IP是否已变为了服务器的IP</p>
<p>测试完成后Ctrl + C关闭SS</p>
<h2 id="配置Systemd管理Shadowsocks"><a href="#配置Systemd管理Shadowsocks" class="headerlink" title="配置Systemd管理Shadowsocks"></a>配置Systemd管理Shadowsocks</h2><p>接下来需要配置SS的自启动，这里用到的是<strong>systemd</strong></p>
<h4 id="新建Shadowsocks管理文件"><a href="#新建Shadowsocks管理文件" class="headerlink" title="新建Shadowsocks管理文件"></a>新建Shadowsocks管理文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>
<p>在文件中复制粘贴以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Shadowsocks Server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks&#x2F;config.json</span><br><span class="line">Restart&#x3D;on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<h4 id="启动Shadowsocks"><a href="#启动Shadowsocks" class="headerlink" title="启动Shadowsocks"></a>启动Shadowsocks</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure>
<h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks-server</span><br></pre></td></tr></table></figure>
<p>自此，配置完成</p>
<h2 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h2><p>BBR是Google最新开发的TCP拥塞控制算法，可以提高带宽</p>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>若结果中出现了<strong>tcp_bbr</strong>，则说明BBR已开启。Ubuntu 18.04版本已经默认开启了BBR，无需再升级内核版本</p>
<h2 id="关于Google-Scholar被墙"><a href="#关于Google-Scholar被墙" class="headerlink" title="关于Google Scholar被墙"></a>关于Google Scholar被墙</h2><p>某些IPv4地址可能会被Google Scholar墙掉，这时候可以配置位于<strong>/etc</strong>目录下的<strong>hosts</strong>文件，利用IPv6地址转发</p>
<p>添加内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Google Scholar Search</span><br><span class="line">2404:6800:4004:81a::200e scholar.google.cn</span><br><span class="line">2404:6800:4004:81a::200e scholar.google.com.hk</span><br><span class="line">2404:6800:4004:81a::200e scholar.google.com</span><br><span class="line">2404:6800:4004:81a::200e scholar.l.google.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，利用以下命令保存并重启网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>机器学习 （1）绪论</title>
    <url>/2020/09/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%EF%BC%881%EF%BC%89%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p>积压了很久的🍉书笔记…</p>
<a id="more"></a>
<h2 id="机器学习是什么？"><a href="#机器学习是什么？" class="headerlink" title="机器学习是什么？"></a>机器学习是什么？</h2><p>机器学习主要研究关于在计算机上从数据中产生“模型”的算法，即学习算法。</p>
<p>有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型，在面对新的情况时，模型会给我们提供相应的判断。</p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li><p><strong>样本</strong></p>
<p>指对于一个事件或对象的描述。</p>
<p>这样的描述通常反映了事件或对象在某些方面的特征和表现。描述的每一项被称为<strong>属性</strong>。属性上的取值称为<strong>属性值</strong>。属性张成的空间被称为<strong>属性空间、样本空间或输入空间</strong>。</p>
<p> 对每个样本的描述通常由多个属性组成，属性的个数称为样本的<strong>维数</strong>。这些属性值可以表示为一个多维向量。因此一个样本也可被称为<strong>特征向量</strong>。每个特征向量都对应了样本空间中的一个点。</p>
</li>
<li><p><strong>数据集</strong></p>
<p>多个样本的集合构成了一个<strong>数据集</strong>。</p>
</li>
<li><p><strong>训练集、训练样本</strong></p>
<p>模型训练过程中使用的数据集被称为<strong>训练集</strong>。训练集中的样本被称为<strong>训练样本</strong>。</p>
</li>
<li><p><strong>样例</strong></p>
<p>带有标记信息的样本被称为<strong>样例</strong>。一个样例通常可以用一个由特征向量和标记信息组成的二元组进行表示。</p>
</li>
</ul>
<h3 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h3><ul>
<li><p><strong>分类</strong></p>
<p>若我们要预测的是<strong>离散值</strong>，则该任务称为<strong>分类</strong>。</p>
</li>
<li><p><strong>回归</strong></p>
<p>若我们要预测的是<strong>连续值</strong>，则该任务称为<strong>回归</strong>。</p>
</li>
<li><p><strong>聚类</strong></p>
<p>将训练集中的样本分成若干个组，每组称为一个“簇”。这样的任务被称为<strong>聚类</strong>。</p>
<p>聚类学习中使用的样本通常<strong>不拥有标记信息</strong>。</p>
</li>
<li><p><strong>监督学习、无监督学习</strong></p>
<p>根据训练数据<strong>是否含有标记信息</strong>，学习任务可大致划分为<strong>监督学习</strong>和<strong>无监督学习</strong>。</p>
<p>分类和回归是前者的代表。</p>
<p>聚类是后者的代表。</p>
</li>
<li><p><strong>泛化</strong></p>
<p>学得模型适用于新样本的能力被称为<strong>泛化能力</strong>。</p>
</li>
</ul>
<h2 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h2><ul>
<li><p><strong>归纳</strong></p>
<p>从特殊到一般，即从具体事实归结出一般性规律。例如<strong>从样例中学习</strong>。</p>
<p>从样例中学习又称为<strong>归纳学习</strong>。</p>
<p>狭义的归纳学习要求从训练样本中学得概念，因此也称<strong>概念学习</strong>。</p>
</li>
<li><p><strong>演绎</strong></p>
<p>从一般到特殊，即从基础原理推演出具体情况。例如<strong>数学证明</strong>。</p>
</li>
</ul>
<p>学习过程可以看作一个在所有假设组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设。可能有多个假设与训练集一致，即存在一个与训练集一致的“假设集合”，称之为<strong>版本空间</strong>。</p>
<h2 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h2><p><strong>通过学习得到的模型对应了假设空间中的一个假设</strong>。</p>
<p>由于版本空间中可能存在多个满足训练集的假设，而这些假设在面临新样本时却有可能产生不同的输出。对于一个具体的学习算法而言，其本身的<strong>“偏好”</strong>将决定最终选择哪一个假设作为最终的模型。</p>
<p><strong>“奥卡姆剃刀原则”</strong>是一种可以使用的偏好，即“若有多个假设与观察一致，则选择最简单的那个”。</p>
<p>事实上，归纳偏好对应了学习算法本身所做出的关于“什么样的模型更好”的假设。</p>
<p>NFL定理指出，<strong>当所有“问题”出现的机会相同、或所有问题同等重要时，不同学习算法的期望性能是相同的</strong>。</p>
<p><strong>NFL定理最重要的寓意在于，当考虑学习算法时应和具体问题相联系</strong>。</p>
<h2 id="人工智能的发展历程"><a href="#人工智能的发展历程" class="headerlink" title="人工智能的发展历程"></a>人工智能的发展历程</h2><ul>
<li><p><strong>推理期</strong></p>
<p>20世纪50年代-70年代初</p>
<p>只要能赋予机器逻辑推理的能力，机器就具有智能。</p>
</li>
<li><p><strong>知识期</strong></p>
<p>20世纪70年代中期起</p>
<p>要使机器具有智能，就必须设法使机器拥有知识。</p>
<p>专家系统是该时期的产物。</p>
</li>
<li><p><strong>广义的归纳学习</strong></p>
<p>20世纪80年代来被研究最多的、应用最广的是“从样例中学习”，即<strong>广义的归纳学习</strong>。其涵盖了<strong>监督学习、无监督学习</strong>等。这方面的主流技术包括：</p>
<ul>
<li><strong>符号主义学习</strong>，代表是<strong>决策树</strong>和<strong>基于逻辑的学习</strong>。</li>
<li><strong>连接主义学习</strong>，代表是<strong>神经网络</strong>。</li>
<li><strong>统计学习</strong>，代表是<strong>SVM</strong>和更一般的<strong>核方法</strong>。</li>
<li><strong>深度学习</strong>，是连接主义学习的一个分支，狭义地说就是“很多层”的神经网络。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>求余和取模</title>
    <url>/2020/08/21/%E6%B1%82%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>今天写题的时候遇到了两个异号数进行%运算的情形，研究了一下才发现求余和取模是不一样的。</p>
<a id="more"></a>
<h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>A、B分别为被除数和除数。</p>
<p>当A可以被B整除时，二者结果都为0。</p>
<p>当A不可以被B整除时，令</p>
<script type="math/tex; mode=display">
C = [A/B]</script><script type="math/tex; mode=display">
R = A - B*C</script><p>求余和取模都是求满足条件的R。但二者差别在于：</p>
<p><strong>求余：使商C尽可能向0靠近。</strong></p>
<p><strong>取模：使商C尽可能向负无穷靠近。</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>取</p>
<script type="math/tex; mode=display">
A = 7,\space B=3</script><p>考虑小数，则</p>
<script type="math/tex; mode=display">
C = A\space/\space B=7\space/\space 3 \approx 2.3</script><p>取整后，产生了两个可能的商 2 和 3 。2 更靠近 0 ，也更靠近负无穷，因此无论求余还是取模，商都应该取 2 ，因此</p>
<script type="math/tex; mode=display">
R = A-B*C=7-3*2=1</script><p>当A、B都取其相反数时同理。可以看出，<strong>当被除数和除数同号时，求余和取模的结果是一致的</strong>。</p>
<p>若</p>
<script type="math/tex; mode=display">
A=7,\space B=-3</script><p>考虑小数，则</p>
<script type="math/tex; mode=display">
C = A\space/\space B=7\space/\space (-3) \approx -2.3</script><p>取整后，产生了两个可能的商 -2 和 -3 。由于 -2 更靠近 0 ，-3 更靠近负无穷，因此求余时商将取 -2，而取模时商将取 -3 。</p>
<p>求余结果</p>
<script type="math/tex; mode=display">
R = A-B*C=7-(-3)*(-2)=1</script><p>取模结果</p>
<script type="math/tex; mode=display">
R = A-B*C=7-(-3)*(-3)=-2</script><p>当A、B都取相反数时同理。可以看出，<strong>当除数和被除数异号，求余和取模结果不一致</strong>。</p>
<h3 id="简单的记忆方式"><a href="#简单的记忆方式" class="headerlink" title="简单的记忆方式"></a>简单的记忆方式</h3><p><strong>求余：</strong>余数和<strong>被除数</strong>同号。</p>
<p><strong>取模：</strong>余数和<strong>除数</strong>同号。</p>
<h3 id="不同语言中的"><a href="#不同语言中的" class="headerlink" title="不同语言中的%"></a>不同语言中的%</h3><p>C、C++、Java：求余</p>
<p>Python：取模</p>
]]></content>
  </entry>
  <entry>
    <title>下岗工人的碎碎念</title>
    <url>/2020/03/14/%E4%B8%8B%E5%B2%97%E5%B7%A5%E4%BA%BA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<p>还完工牌和电脑，三天前从北京回了家，我四个月的实习生活正式结束了。</p>
<p><center><img src="/2020/03/14/%E4%B8%8B%E5%B2%97%E5%B7%A5%E4%BA%BA%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/1.jpg" width="50%"></center><br><a id="more"></a></p>
<h3 id="从无业游民到打工仔"><a href="#从无业游民到打工仔" class="headerlink" title="从无业游民到打工仔"></a>从无业游民到打工仔</h3><p>刚进大学的时候，有时候会听说某某学长/学姐去了BAT。对于当时还只会写黑底白字cpp程序的我来说冲击不要太大，心中唯一的感觉是羡慕。知乎的焦虑轰炸和许多被夸大其词的“BAT面试题”让那时的我只觉得BAT只是一个遥不可及的梦。“读完本科和研究生能进个BAT就好了呀”。小白的梦想就是这么简单而枯燥。</p>
<p>第一次听说头条是它和腾讯大战的时候。当时对这个公司并没有特别的感觉。过去挑战BAT的公司也不在少数，可人们记住的还是只有BAT。我寻思或许不久之后这家公司也将和前人无二，被时代的车轮碾过，不留痕迹。</p>
<p>时间推移，国内互联网行业发展迅猛，自己也不再是那个认为互联网=BAT的一无所知的小白了，知道了还有规模和实力并不十分逊色于BAT的TMD，还知道了处于食物链顶端的FLAG。虽然不是只会用cpp写控制台了，但感觉自己离大厂距离还是很远。偶然又了解到头条特别舍得给钱，应届白菜能开出30+。对于当时只希望毕业之后能拿个20的offer的我来说又是一次大冲击。除了给钱多，同时了解到的是头条的面试也特别难，需要手撕算法题（后来才发现其实大厂都要）。从那个时候起，头条在我心中的地位已经和BAT差不多了，甚至还略高一点点？毕竟没有人和钱过不去嘛。</p>
<p>到了大三下学期，随着对行业的进一步认知，以及和真正拿到大厂offer的学长的接触，这个时候我意识到并不是“人中龙凤”才有机会进大厂，我们普通人努努力也有机会。也知道了头条其实叫字节跳动，今日头条只是他们家其中一个产品。他们家还有一个爆款叫抖音。尽管很希望去看一看工业界的运作流程，了解一下大厂的做事方式，但由于要准备保研，这个念头也只能留在心里。那时心里根本不觉得保研和实习两件事可以兼顾。虽然听说上届有学长同时拿到了浙大CAD和腾讯的offer，但我只简单地把这种人归类于神仙。当时只想着能拿个交浙南的offer，大学圆满。</p>
<p>真正意识到保研和实习是有可能兼顾的还是因为身边的同学。先是班上有两个同学先后拿到了字节跳动的前端和客户端实习offer，再到室友八月拿到抖音客户端的offer。直到突然有一天我发现，所有室友和另一个兄弟寝室的哥们全都找到了实习，只剩下了我一个无业游民，而他们也和我一样经历了保研中的所有事情。从小到大我们都在说环境会对人产生很大影响，此时此刻我终于有了深刻的感受。家长们为了把孩子送进名校争得头破血流大概也就出于这么个道理。我归因于好的环境会带来更强大的Peer Pressure，激起人的好胜心从而让人奋进。说白了就是你心里会想，大家学的都一样，他行凭啥我不行。</p>
<h3 id="艰苦地找工地"><a href="#艰苦地找工地" class="headerlink" title="艰苦地找工地"></a>艰苦地找工地</h3><p>时间来到九月初，尽管保研还未尘埃落定，我心里却早已急不可耐，迫切地想找一份实习。加之室友也说面试时间可以约晚一点，所以虽然此时的我啥也没准备，忐忑之下还是把简历投了出去。最初我投递的都是一些小公司，想着先积累一些面试经验，为后续字节跳动的面试做准备。目标岗位是后端。</p>
<p>第一次面试很快就来了，是杭州的一家小型公司，形式是电话面试。现在看来问的都是一些非常基础的知识，比如JVM的GC、Spring的IOC和AOP、MySQL的索引等等，甚至都没有算法题。然而那时啥都没准备，脑子空空的我自然是答得非常差。面试持续了三十分钟，在我一连串的“这个不太了解”中，面试官终于没能继续下去，最后意味深长说了句“不好意思，耽误你时间了啊”。后来一回想，大概是我耽误她时间了吧（狗头。</p>
<p>总之第一次面试很失败，唯一的收获是让我认识到靠临阵磨枪是面不过后端岗的，要准备的知识太多，于是我决定把求职意向从后端改为客户端。一是考虑到目前字节跳动对客户端的需求比较大，机会更多，二是周围同学面的几乎也都是客户端，经验积累更多，三是客户端要准备的知识相较于后端稍微少一点。做完决定，改完简历，我又投了一波。为了给自己更大的压力，这次直接投的全是大厂，包括字节跳动。心里想着约完面试时间就能压迫自己准备了。字节跳动的面试邀约来的很快，我约了是9月底，等填完保研系统再顺手拿个offer，岂不美哉。</p>
<p>事实证明，想法是美好的，现实往往没有那么顺利。时间来到了24号，我还在为保研的事忙得焦头烂额，《深入理解Java虚拟机》自然是没有翻开过的。意识到这种知识储备肯定要挂，我只能让HR把面试时间推迟到了国庆之后。</p>
<p>填完系统，当早早拿到offer和不准备实习的同学们正准备享受即将到来的70周年国庆和阳光明媚，自由自在的大四生活时，我的苦日子才刚开始。国庆节当然是不存在的，我磕磕绊绊的把《深入理解Java虚拟机》中的重要内容过了一遍，看了看HashMap的源码解析，补了补Android的基础知识，再刷了几篇面经就匆忙上阵面试了。</p>
<p>第一次面大厂，还要手撕代码，说不紧张那是假的。然而幸运的是，面试官的提问几乎全部精准命中我准备的内容。而且由于准备的时间很近，很多问题的细节都说得不错。面试结束立马就被告知HR会和我约二面的时间。人生嘛，总是起起落落落落落落的，我只等到了HR告诉我说觉得我实习时间太短，愿意走校招才安排二面。于是我的简历又回到了他们的简历海里。好在同学帮了大忙，让他们组把我简历又捞了起来，才总算是约上了二面。在等待二面的过程中还被百度捞了一次，来了一轮电话面。个人感觉百度的面试风格和字节很不一样，字节更注重计算机基础和算法，而百度则问了很多Android相关的知识，重要的组件几乎都问了个遍，另外还问了我准备得不多的数据库。当时Android的许多知识准备得还不太好，因此自然是没了下文。我倒也不太在意，就当给二面积累了点儿经验。</p>
<p>二面的日子到了，这次几乎都在问Android，自然是存在知识死角。算法题来了两道，有一道写得不是特别好，因为边界条件的问题被怼了。最后的提问环节还傻乎乎的说之后考虑读博，让面试官觉得我来做客户端可能对双方帮助都不大。结果是我的简历又回到了简历海。得亏身边去字节的人多，三面被推到了我室友的部门。这一面除了Android知识的轰炸，还有一个鬼畜的情景题，问如何设计一个下载工具。面完我感觉就不是特别好，最后还是没有过，给的反馈是我面的这个HC是要做今日头条的，上手时间太长，我实习时间又太短。也不知是真的还是为了安慰我。此时能捞我的只剩下另一个在抖音的室友，但经过两轮打击，再加上抖音的要求肯定只会更高，我是没啥信心和动力再去他们组面一次的。再加上此时时间已经到了10月中旬，秋招都快结束了，我自觉再被其他组捞起来的希望渺茫。客户端的路也这么被堵死了。</p>
<p>身边只剩下了一个做测试的同学。抱着死马当活马医的心态，我让他捞了一次，在一周之后等来了一个测开岗的面试邀约。这时的我早已不在意岗位，只要能进去啥岗都可以接受。在恶补了几天测试的基础知识之后，我最后的机会来了。一面二面紧挨着，二面中的一道算法题脑子一抽没做出来。幸亏自己争取了一下，让面试官补了一道，不然我可能真的会当一整学期无业游民。三面面试官是我后来的leader，他的面试是这段时间以来我经历的最魔幻的面试。开场就用一个“为什么电梯里摄像头要装在轿厢左后方的角落里？”把我问懵了。硬着头皮扯了几句之后又是两个很宽很大的问题，自觉答得也不怎么样。好在后面的两道代码题表现还不错，最后还是让我过了。第二天又经历了一轮HR面，耗时一整月，我终于找到了收留我搬砖的工地。</p>
<h3 id="搬砖之旅"><a href="#搬砖之旅" class="headerlink" title="搬砖之旅"></a>搬砖之旅</h3><p>拿到offer，紧绷的心放松了不少，痛痛快快地和妹子去杭州溜达了一趟，顺便看好了要租的房子。在学期过去一半之后，我总算来到了北京，开始了实习生活。</p>
<p>入职办理在中航广场，本以为入职就是交交材料，领一下电脑和工牌，一会儿就能结束，于是我饿着肚子就去了。没想到等着我的是一整个上午的入职会，和我一同办入职的新同学人数也远超我预料，整整坐满了会议室的两张大桌子。入职会的内容和我想的倒是差不多，无非就是身份查验，签合同，安装办公软件，看公司宣传片之类的事情。</p>
<p>入职会结束的时候已经到了饭点，接我的HR却迟迟没到，最后还是我带着另外两个同在一栋办公楼的新同学过去的。也第一次知道了大公司还有着穿梭车这种东西，15分钟一班，往返在公司的各个办公点之间，相当于公司员工的免费公交车。我的办公点在紫金数码园。暑假参加过推免面试的软件所就在隔壁。当时就在附近看到过戴字节跳动工牌的人，没想到还挺有缘，最后自己也来了这里搬砖。</p>
<p>饭后见了Leader和Mentor，认识了一下组内同学，了解到做的工作其实就是Web开发，准确的说是全栈开发，每个人都需要从前端写到后端。技术栈是Vue + Django。这俩我以前都没写过，因此接下来半个月也没有活，一直在配环境和学习，周末还能和同学们进城走一走，生活还是挺惬意的。</p>
<p>摸鱼的日子也不好意思一直过下去，自己也想着过来应该要有点产出。正好Mentor把我派给了组内的另一个缺人力的同学，于是接到了我的第一个需求（实际上整个实习期都主要在做这个）。需求的大背景是当前公司内许多数据分散在不同的平台上，产品线的同学在发版前需要去各个平台都检查一遍，十分不便。我们的工作就是将这些数据整合到我们的测试平台上。我负责其中一个统计APP中各种Crash率的子模块。</p>
<p>刚接到需求的时候其实有点overwhelmed，许多业内“黑话”我还没摸清，发版流程也不懂，再加上当时Vue才刚开始学，真的有点不知道从何下手。我也不太愿意问，一方面是想着同组同学都还有自己的工作，不好意思打扰人家，另一方面也是担心自己问的问题太傻，让人心里有想法，比如这都不知道，这个憨憨是怎么进来的。于是我就犟着自己盲人摸象，进度自然是很慢。后来在知乎看到一个同为刚进入字节的新同学写的一篇反思，里面说到刚入职的迷茫期就应该靠脸皮厚多问人度过。现在回想确实很有道理，你遇到的问题同组的同学大概率也有遇到，他们的一句指点往往能帮你直接解决问题。况且有些问题搜索引擎也不一定能找到答案，比如当牵扯到公司内部的库时。相比起那一点虚荣心，显然还是节省下来的那些时间更有价值。</p>
<p>万事开头难，首先实现方案中就有许多细节等待落实。带我的同学认为需要利用定时任务爬取数据入我们的库，这里就引出了许多问题：定时任务的时间间隔设置为多久合适？爬取的数据量有多大？爬取的时间有多长？接口中哪些字段是我们需要的？这些只能靠着自己慢慢摸索，期间还碰到了没有接口文档，字段含义全靠猜测、爬取分页过大不返回结果、部分字段有时会因为编码问题无法存入数据库等一系列奇奇怪怪的问题。于是起码一周有余的时间我都花在了写数据爬取相关的逻辑上，最后花了半个月才写完第一版后端代码，换成在学校做课程设计黄花菜都凉了。好在带我的同学很宽容，给我排了很长的工期，赶在ddl前加了几天班，还是按时交工了。</p>
<p>那时的我还不知道未来还有很长的返工的日子等着我。业务方无法接受定时任务带来的延时，要求数据和数据源平台完全同步。对方的数据库必然是拿不到的，因此只能改变方案，牺牲部分响应时间，请求时后端直接去数据源爬取，不再入库。这意味着整个后端逻辑几乎都要重写。Model层的代码完全失去作用，Service层代码也需要大改。加上期间业务方还在不断对模块提新需求和春节休假，导致这一个模块最终做到了二月中旬，前前后后弄了整整两个半月。吃过了苦头，对工作中沟通的重要性又有了新的认识。如果一开始就把各种细节都确定好，这次返工是完全可以避免的。</p>
<p>房子只租到了三月初，加之自己也要准备毕业设计了，后续我只接了一个展示当前版本未合入代码的模块，业务逻辑也差不多，另外还完成了两个模块的国际化，便临近了离职的日子。遗憾的是，因为疫情原因，直到离职我也没能再进入一次办公楼。甚至交还电脑都是在中航园区保安处，连给矮楼再拍一张照片的机会都没有。</p>
<h3 id="搬砖时的一些思考"><a href="#搬砖时的一些思考" class="headerlink" title="搬砖时的一些思考"></a>搬砖时的一些思考</h3><p>搬砖的时候我一直在想的一个问题是，如何判断一个研究方向是不是企业需要的呢？下面是我根据这段时间的观察得出的一些浅薄体会。</p>
<p>岗位的需求要从企业的目标和组成出发。要明确的一点是国企和私企在这两个方面有着很大不同。ICT行业的龙头企业均为私企，因此这里的分析也只针对私企。又由于我入职的是技术类岗位，对其他如法务、人力、行政、运营之类的岗位不太了解，所以分析中涉及到的岗位也都限定在技术类。</p>
<p>首先，私企最重要的目标当然是盈利。盈利是靠服务或产品创造的。举个例子，美团向外提供外卖服务，并从中赚取中间商差价。此外，他们还提供其他的服务，例如订机票、订酒店等等。最终这些服务都被整合到了一个叫美团的APP上，这就是他们的产品。事实上，大部分的服务最终都变成了看得见摸得着的产品，那么为什么还要单独强调“服务”这个概念呢？因为确实还存在着那么一些没办法具象化的话的东西，比如某些公司提供的一些咨询服务，他们利用专业知识和经验积累为客户提供解决方案。再举个例子，小明想要开一家公司，公司内部需要布置网络，而小明又不懂技术，这个时候他就可以向提供ICT技术咨询服务的公司求助，他们根据小明的需求告诉他需要买多少台服务器，各种设备应该选用什么样的配置，公司内应该怎么组网等等，甚至可以派人驻场直接帮助小明把这一切打理好，小明只需要找好团队公司就能直接运营了。这种服务的产物往往是一些意见，而且由于客户的需求不同会因人而异，不存在一个通用的模板，自然也不方便变成具象化的产品。</p>
<p>企业依靠服务和产品盈利，除开维持公司正常运转的岗位，其余人员的组成一定是围绕它们展开的。因此，分析企业对岗位的需求可以从他们的产品出发。我把公司内的技术岗位分成两条线：<strong>业务线</strong>和<strong>支撑线</strong>。业务线团队是直接负责公司产品的研发的。以字节跳动的抖音为例，业务线就是直接负责抖音这个APP的团队，这个团队产出的代码最终打成包上架到各个应用商店，交付给用户。支撑线通常是为业务线提供工具或维护公司正常运转的团队，例如架构团队，他们负责整个公司基础设施的构建，包括各种数据中心，内网搭建，虚拟化等。再上层一点的团队负责公司通用组件的研发与维护，例如各种数据库、消息队列等中间件。总而言之，支撑线团队负责的是一些抽象程度高，通用性强的组件，相较于业务线更为底层。他们的产出不直接面向用户，而是作为开发的必要工具提供给业务线团队。另外，为了维护公司的正常运转，会存在着许许多多的内部系统，例如工资系统、报销系统、请假系统等等。当然换种角度看这些团队也可以被归到业务线，只是他们的产品是对内的，而不是对外的。再比如，算法团队也可以算到支撑线中。例如推荐算法团队提供封装好SDK供抖音业务线团队调用。还有一种特殊的支撑线是安全部门，负载保障公司和产品的信息安全。事实上，这种分析思想不仅仅适用于ICT行业中的技术岗，人力、行政、财务、法务等也都是为了保障公司的正常运转。</p>
<p>了解了岗位分类，接下来就要落实到具体的岗位了。先说业务线，业务线所需岗位和产品的形式直接相关。如果产品是APP，那么客户端工程师肯定必不可少，同时，APP中会存在服务端的逻辑，所以也需要服务端工程师。此外，为了保证产品质量，还需要配套测试团队。如果产品是Web形式的，那就需要前端后端，客户端就没有需求了。再进一步，华为、小米等一些企业的产品是各种硬件设备，如手机电脑等，他们业务部门的组成又不一样了。以手机为例，可能有的团队负责OS，有的团队负责相机，有的团队负责通信模块、有的团队负责各种原生APP。根据团队职能不同其内设岗位将再进行细分。再说支撑线。在互联网企业中，支撑线提供的岗位大同小异，因为各种基础设施所有的公司都有需求。在当前上云已成为常态的背景下，这部分岗位主要来自IaaS和PaaS的需求，例如容器、负载均衡、数据库、缓存、消息队列、大数据平台等。</p>
<p>此外，一些体量大，实力强的企业往往还会养一个研究团队，用于探索行业的前沿问题，以保持自己的行业领先地位。研究团队涉及到的方向大多还是和公司业务相关的，研究团队的人员往往也会积极寻求和业务部门的合作，用于落地研究成果。因为一个现实的问题是企业对这些部门的投入往往会大于他们为公司创造的看得见的价值。如果不积极寻求与业务部门的合作，当危机来临时这种部门往往会最先被裁掉。相反，业务线团队的被裁风险会相对较小，因为他们是直接为公司创造价值的团队。另外由于业务部门是直接面向用户的部门，交付压力会特别大。因为各种发版日期，产品的发布日期都是定死的，从而也导致了业务部门的加班风险很大。但收获往往和付出成正比，业务部门的年终奖相较于其他团队也会更多。</p>
<h3 id="下岗后的打算"><a href="#下岗后的打算" class="headerlink" title="下岗后的打算"></a>下岗后的打算</h3><p>前前后后拖了半个月，这篇总结终于到了尾声。原本我设想只是简短的记录一下实习生活，没想到写着写着就成了6000字的大块头。而此刻毕设却还没有任何进展（似乎把精力花在了奇怪的地方）。</p>
<p>最后到了Flag环节。这个学期的计划包括每天至少一道算法题（还没倒！），学完CSAPP，自学一下编译原理（是当初偷懒没选欠下的债）。最大的希望当然是赶快搞明白毕设，顺利毕业，早日和妹子、旁友们一起毕业旅行。</p>
<p> End.</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Systemd进行自动部署</title>
    <url>/2021/02/25/%E4%BD%BF%E7%94%A8Systemd%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>作为实验室项目服务器的运 (bei) 维 (guo) 工 (xia) ，我长期经受着各种各样dirty工作的鞭打：频繁bug导致的重新部署、机房莫名奇妙的断电、nohup运行不优雅…</p>
<p>终于，在又一次因机房断电重启服务后我决定做点什么来减轻一下自己的压力。于是我注意到了Systemd。</p>
<a id="more"></a>
<h3 id="什么是Systemd？"><a href="#什么是Systemd？" class="headerlink" title="什么是Systemd？"></a>什么是Systemd？</h3><p>早期Linux使用SysVinit来做系统初始化，然而其具有着串行启动、功能单一诸多局限性，于是Systemd应运而生。它为系统的启动和管理提供了一套完整的解决方案。</p>
<p>Systemd可以管理所有的系统资源，不同资源统称为Unit。Unit共12种，包括</p>
<ul>
<li>service: 系统服务</li>
<li>target: 多个unit构成的组</li>
<li>device: 硬件设备</li>
<li>mount: 文件系统的挂载点</li>
<li>automount: 自动挂载点</li>
<li>path: 文件或路径</li>
<li>scope: 不是由Systemd启动的外部进程</li>
<li>slice: 进程组</li>
<li>snapshot: Systemd快照，可以切回某个快照</li>
<li>socket: 进程间通信的socket</li>
<li>swap: swap文件</li>
<li>timer: 定时器</li>
</ul>
<p>Systemd包括了一系列命令，本次使用到了<code>systemctl</code>和<code>journalctl</code>，前者为Systemd的主命令，后者用于操作Systemd的日志服务。下面是二者一些常用的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl常用命令</span></span><br><span class="line"><span class="comment"># 启动指定的服务</span></span><br><span class="line">systemctl start foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭指定的服务</span></span><br><span class="line">systemctl stop foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启指定的服务</span></span><br><span class="line">systemctl restart foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载指定的服务（支持时）</span></span><br><span class="line">systemctl reload foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的状态</span></span><br><span class="line">systemctl status foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定unit的所有底层参数</span></span><br><span class="line">systemctl show foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的描述</span></span><br><span class="line">systemctl cat foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下次启动时或满足其他触发条件时设置服务为启用</span></span><br><span class="line">systemctl <span class="built_in">enable</span> foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下次启动时或满足其他触发条件时设置服务为禁用</span></span><br><span class="line">systemctl <span class="built_in">disable</span> foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出可启动或停止的服务列表</span></span><br><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务配置变更时使用</span></span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># journalctl常用命令</span></span><br><span class="line"><span class="comment"># 查看所有日志</span></span><br><span class="line">journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">journalctl --since <span class="string">&quot;20 min ago&quot;</span></span><br><span class="line">journalctl --since=<span class="string">&quot;2012-10-30 18:17:16&quot;</span></span><br><span class="line">journalctl --since yesterday</span><br><span class="line">journalctl --since <span class="string">&quot;2015-01-10&quot;</span> --until <span class="string">&quot;2015-01-11 03:00&quot;</span></span><br><span class="line">journalctl --since 09:00 --until <span class="string">&quot;1 hour ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看实时滚动的日志</span></span><br><span class="line">journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定Unit的日志</span></span><br><span class="line">journalctl -u foo.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">journalctl --vacuum-size=500M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件的最长保存时间</span></span><br><span class="line">journalctl --vacuum-time=2d</span><br></pre></td></tr></table></figure>
<h3 id="service编写"><a href="#service编写" class="headerlink" title="service编写"></a>service编写</h3><p>服务器上需要配置的是一个前后端分离的web项目，二者独立更新，因此为二者分别编写service是更加灵活的选择。</p>
<p>前端服务的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service-pattern-frontend.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Service Pattern System Frontend  <span class="comment"># 服务描述</span></span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=150  <span class="comment"># Start的最长等待时间</span></span><br><span class="line">WorkingDirectory=/home/cbs/workspace/servicesysclient  <span class="comment"># 工作目录</span></span><br><span class="line">ExecStartPre=/usr/<span class="built_in">local</span>/bin/npm run build  <span class="comment"># Start前先执行build</span></span><br><span class="line">ExecStart=/home/cbs/.yarn/bin/serve -s build -l 6052  <span class="comment"># 启动监听</span></span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -INT <span class="variable">$MAINPID</span>  <span class="comment"># 使用SIGINT结束服务器的监听</span></span><br><span class="line">RestartSec=15  <span class="comment"># 重启前等待时间</span></span><br><span class="line">Restart=on-failure  <span class="comment"># 重启策略</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>后端服务的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># service-pattern-backend.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Service Pattern System Backend  <span class="comment"># 服务描述</span></span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/home/cbs/workspace/servicesysserver  <span class="comment"># 工作目录</span></span><br><span class="line">ExecStart=/home/cbs/anaconda3/bin/python manage.py runserver 0.0.0.0:6051  <span class="comment"># 启动Django</span></span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -TERM <span class="variable">$MAINPID</span>  <span class="comment"># 使用SIGTERM结束服务器的监听</span></span><br><span class="line">RestartSec=15  <span class="comment"># 重启前等待时间</span></span><br><span class="line">Restart=on-failure  <span class="comment"># 重启策略</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>简要介绍一下这两个service文件。首先看二者的相同部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># foo.service</span></span><br><span class="line">[Unit]</span><br><span class="line">...</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>[Unit]中的<code>After=network.target</code>表示当前服务需要在启动network.target之后才能启动。不过，由于项目中的前后端都跑在私有地址上，再通过端口映射暴露到外网，根据<a href="https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/">NetWorkTarget</a>，不添加这一设置也是可行的，后面可以找时间再测试一下。</p>
<p>[Install]中定义了<code>WantedBy=multi-user.target</code>，这一配置是服务实现开机自启动的关键。当执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> foo.service</span><br></pre></td></tr></table></figure>
<p>时，<code>foo.service</code>将在<code>/etc/systemd/system/multi-user.target.wants</code>下创建一个符号链接。在终端环境下，<code>multi-user.target</code>是默认的启动target，这个组里的所有服务都将开机启动。</p>
<h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><p>以前端的<code>service-pattern-frontend.service</code>为例，记录一下完整的配置流程。</p>
<p>首先创建.service文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch service-pattern-frontend.service</span><br></pre></td></tr></table></figure>
<p>并填入上面的配置内容。</p>
<p>接着执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp service-pattern-frontend.service /etc/systemd/system</span><br></pre></td></tr></table></figure>
<p>将文件拷入保存service的目录中。</p>
<p>此时输入<code>systemctl cat service-pattern-frontend.service</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) cbs@ubuntu:/$ systemctl cat service-pattern-frontend.service </span><br><span class="line"><span class="comment"># /etc/systemd/system/service-pattern-frontend.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Service Pattern System Frontend</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=150</span><br><span class="line">WorkingDirectory=/home/cbs/workspace/servicesysclient</span><br><span class="line">ExecStartPre=/usr/<span class="built_in">local</span>/bin/npm run build</span><br><span class="line">ExecStart=/home/cbs/.yarn/bin/serve -s build -l 6052</span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -INT <span class="variable">$MAINPID</span></span><br><span class="line">RestartSec=15</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>已经可以看到配置文件的内容。</p>
<p>之后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start service-pattern-frontend.service</span><br></pre></td></tr></table></figure>
<p>启动服务。</p>
<p><code>npm run build</code>的时间较长，因此在配置中额外设置了<code>TimeoutStartSec</code>，延长了等待时间。若未设置这一字段，Systemd将采用在<code>/etc/systemd/system.conf</code>中定义的<code>DefaultTimeoutStartSec=90s</code>。采用默认值可能使得<code>npm run build</code>来不及完成。</p>
<p>启动成功后，输入<code>systemctl status service-pattern-frontend.service</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) cbs@ubuntu:/$ systemctl status service-pattern-frontend.service</span><br><span class="line">● service-pattern-frontend.service - Service Pattern System Frontend</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/service-pattern-frontend.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2021-02-26 01:26:48 CST; 14h ago</span><br><span class="line">  Process: 26222 ExecStartPre=/usr/<span class="built_in">local</span>/bin/npm run build (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 26422 (node)</span><br><span class="line">    Tasks: 11 (<span class="built_in">limit</span>: 4915)</span><br><span class="line">   CGroup: /system.slice/service-pattern-frontend.service</span><br><span class="line">           └─26422 node /home/cbs/.yarn/bin/serve -s build -l 6052</span><br><span class="line"></span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You can also analyze the project dependencies: https://goo.gl/LeUzfb</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: The project was built assuming it is hosted at /.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You can control this with the homepage field <span class="keyword">in</span> your package.json.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: The build folder is ready to be deployed.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You may serve it with a static server:</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]:   serve -s build</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: Find out more about deployment here:</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]:   bit.ly/CRA-deploy</span><br><span class="line">Feb 26 01:26:48 ubuntu systemd[1]: Started Service Pattern System Frontend.</span><br><span class="line">Feb 26 01:26:48 ubuntu serve[26422]: INFO: Accepting connections at http://localhost:6052</span><br></pre></td></tr></table></figure>
<p>可以看到前端服务已经启动成功。</p>
<p>使用<code>journalctl -f -u service-pattern-frontend.service</code>可以查看启动日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) cbs@ubuntu:/$ journalctl -f -u service-pattern-frontend.service</span><br><span class="line">-- Logs begin at Fri 2020-07-31 12:30:45 CST. --</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You can also analyze the project dependencies: https://goo.gl/LeUzfb</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: The project was built assuming it is hosted at /.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You can control this with the homepage field <span class="keyword">in</span> your package.json.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: The build folder is ready to be deployed.</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: You may serve it with a static server:</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]:   serve -s build</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]: Find out more about deployment here:</span><br><span class="line">Feb 26 01:26:48 ubuntu npm[26222]:   bit.ly/CRA-deploy</span><br><span class="line">Feb 26 01:26:48 ubuntu systemd[1]: Started Service Pattern System Frontend.</span><br><span class="line">Feb 26 01:26:48 ubuntu serve[26422]: INFO: Accepting connections at http://localhost:6052</span><br></pre></td></tr></table></figure>
<p>最后，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> service-pattern-frontend.service</span><br></pre></td></tr></table></figure>
<p>设置开机自启动，配置完毕。</p>
<p>若对service文件有任何修改，记得使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>重新载入配置文件。</p>
<p>由于后端服务有一功能会有大量std输出，曾经出现过40多G的nohup.out，因此我还额外配置了一下日志可占据的最大空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl --vacuum-size=1G</span><br></pre></td></tr></table></figure>
<p>之后进行代码更新时，只需要重启一次服务即可，不用再kill，serve二连。日志也有了统一管理的工具，不需要再去nohup.out里一行行找。更重要的是，不用再担心哪天机房断电我又被叫去重启服务了，好耶！</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd.service</a></li>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html">systemd.exec</a></li>
<li><a href="https://www.freedesktop.org/wiki/Software/systemd/FrequentlyAskedQuestions/">systemd/FAQ</a></li>
<li><a href="https://www.freedesktop.org/wiki/Software/systemd/NetworkTarget/">NetworkTarget</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">Systemd 入门教程：命令篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇</a></li>
<li><a href="https://blog.csdn.net/mrmengj/article/details/112306151">如何自定义自己的 systemd service 守护进程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html">浅析 Linux 初始化 init 系统: Systemd</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
